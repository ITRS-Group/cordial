# This is the default configuration included in the `gdna` program.

# Please see the main example `gdna.yaml` file for explanations of the
# settings.

# Some additional comments exist in this file for sections that are not
# normally changed by users; See below for more.

gdna:
  site-name: ITRS
  licd-sources: 
    - "http://localhost:7041"
    - "https://localhost:7041"
  licd-reports:
    # - "~/geneos/licd/licds/*/reporting/summary*"
  schedule: "*/15 * * * *"
  email-schedule: ""
  stale-after: 12h
  licd-timeout: 10s
  licd-chain: ""
  licd-skip-verify: false
  log:
    filename: ./gdna.log
    max-size: 10
    max-backups: 50
    max-age: 14
    compress: true
    rotate-on-start: true

geneos:
  netprobe:
    hostname: localhost
    port: 8101
    secure: true
    skip-verify: true
  entity: GDNA
  sampler: GDNA
  max-rows: 500
  scramble: false
  dataview-create-delay: 0

xlsx:
  password: ""
  scramble: true
  summary-report: gdna-summary
  formats:
    int: 1
    percent: 9
    datetime: "yyyy-mm-ddThh:MM:ss"
    min-width: 10.0
    max-width: 30.0
  conditional-formats:
    ok: 43d815
    warning: fcd600
    critical: ee1212
    undefined: ffffff

email:
  smtp-server: smtp.example.com
  port: 0
  tls: default
  tls-insecure: false
  timeout: 10s
  username: ""
  password: ""
  key-file: ""
  credentials-file: ""

  subject: ITRS GDNA EMail Report
  from: sender@example.com
  to: recipient@example.com
  cc: ""
  bcc: ""
  body-reports: gdna-summary
  contents: [ xlsx ]
  xlsx-name: itrs-gdna-report.xlsx
  html-name: itrs-gdna-report.html
  scramble: true
  html-preamble: |
    <html>
    <head>
      <style>
      table.gdna-headlines,
      table.gdna-headlines th,
      table.gdna-headlines td,
      table.gdna-dataview,
      table.gdna-dataview th,
      table.gdna-dataview td {
        table-layout: fixed;
        font-family: Lucida Console, monospace;
        border: 1px solid black;
        border-collapse: collapse;
        padding: 5px;
        text-align: left;
        vertical-align: top;
      }
      td.gdna-dataview {
        word-wrap: break-word;
      }

      </style>
    </head>
    <body>
      <h1>ITRS Geneos GDNA Default Template</h1>

      <p>This content has been generated by the default template built
      into the gdna program from the ITRS <a
      href="https://github.com/ITRS-Group/cordial">cordial</a> tools.
      It is normally only seen when testing. If you did not expect to
      receive this please contact the sender and let them know.</p>

      <h2>Report Summary</h2>

      <p></p>
  html-postscript: |
    </body>
    </html>

# `filters-file` contains the on-disk list of filters: includes,
# excludes and groups.
#
# It is intended to be created, read and written by the gdna program
# directly and should not be hand edited. It is used as a persistent
# store for the data to be loaded into the SQLite temporary tables
# before each reporting run, so as to not require database access
# outside the main program thread.
#
# The file can be YAML or JSON and the contents must be in the form:
#
#     exclude:
#       CATEGORY:
#         - name: NAME
#           user: Who
#           timestamp: ISO8601
#           comment: Why
#           source: From
#     include:
#       ...
#     groups:
#       ...
#
# or
#
#     {
#        "exclude": {
#           "CATEGORY": [
#             {
#               "comment": "test",
#               "name": "PROD_02",
#               "source": "cli",
#               "timestamp": "2024-09-20T17:05:42+01:00",
#               "user": "Peter"
#             }
#           ]
#        }
#     }
#
# where `CATEGORY` must match on of the types in the `exclude` section
# below. The files are read and written using the cordial config.Load(),
# config.Save() functions.
#
# The default is `gdna-filters.yaml` in the normal config directories
#
# include and exclude filter categories must be made up of tables with exactly one column
filters:
  file: ""
  exclude:
    gateway:
      table: gateway_exclude
      column: gateway
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.gateway.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.gateway.table} (
          ${filters.exclude.gateway.column} TEXT NOT NULL COLLATE NOCASE
        );
    server:
      table: server_exclude
      column: server
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.server.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.server.table} (
          ${filters.exclude.server.column} TEXT NOT NULL COLLATE NOCASE
        );
    hostid:
      table: hostid_exclude
      column: hostid
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.hostid.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.hostid.table} (
          ${filters.exclude.hostid.column} TEXT NOT NULL COLLATE NOCASE
        );
    source:
      table: source_exclude
      column: source
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.source.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.source.table} (
          ${filters.exclude.source.column} TEXT NOT NULL COLLATE NOCASE
        );
    plugin:
      table: plugin_exclude
      column: plugin
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.plugin.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.plugin.table} (
          ${filters.exclude.plugin.column} TEXT NOT NULL COLLATE NOCASE
        );

  include:
    gateway:
      table: gateway_include
      column: gateway
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.gateway.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.gateway.table} (
          ${filters.include.gateway.column} TEXT NOT NULL COLLATE NOCASE
        );
    server:
      table: server_include
      column: server
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.server.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.server.table} (
          ${filters.include.server.column} TEXT NOT NULL COLLATE NOCASE
        );
    hostid:
      table: hostid_include
      column: hostid
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.hostid.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.hostid.table} (
          ${filters.include.hostid.column} TEXT NOT NULL COLLATE NOCASE
        );
    source:
      table: source_include
      column: source
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.source.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.source.table} (
          ${filters.include.source.column} TEXT NOT NULL COLLATE NOCASE
        );
    plugin:
      table: plugin_include
      column: plugin
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.plugin.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.plugin.table} (
          ${filters.include.plugin.column} TEXT NOT NULL COLLATE NOCASE
        );

  groups:
    gateway:
      table: grouping_gateways
      column: gateway
      create: | #sql
        DROP TABLE IF EXISTS ${filters.groups.gateway.table};
        CREATE ${db.temporary-table} TABLE ${filters.groups.gateway.table} (
          grouping TEXT NOT NULL,
          gateway TEXT NOT NULL
        );
    server:
      table: grouping_servers
      column: server
      create: | #sql
        DROP TABLE IF EXISTS ${filters.groups.server.table};
        CREATE ${db.temporary-table} TABLE ${filters.groups.server.table} (
          grouping TEXT NOT NULL,
          server TEXT NOT NULL
        );
    source:
      table: grouping_sources
      column: source
      create: | #sql
        DROP TABLE IF EXISTS ${filters.groups.source.table};
        CREATE ${db.temporary-table} TABLE ${filters.groups.source.table} (
          grouping TEXT NOT NULL,
          source TEXT NOT NULL
        );
    plugin:
      table: grouping_plugins
      default: |
        e4jms-plugins,e4jms-*
        ibmi-plugins,ibmi-*
        mq-plugins,mq-*
        wts-plugins,wts-*
        x-plugins,x-*
        sybase-plugins,sybase*
        prometheus-plugins,*prometheus*
        tib-plugins,tib*
        jmx-plugins,jmx*
        cloud-plugins,aws-plugin
        cloud-plugins,azure-plugin
        cloud-plugins,gcp-plugin
      column: plugin
      create: | #sql
        DROP TABLE IF EXISTS ${filters.groups.plugin.table};
        CREATE ${db.temporary-table} TABLE ${filters.groups.plugin.table} (
          grouping TEXT NOT NULL,
          plugin TEXT NOT NULL
        );

db:
  temporary-table: TEMPORARY
  file: gdna.sqlite
  dsn: "file:${db.file}"
  on-open: > #sql
    PRAGMA journal_mode='wal';
    PRAGMA synchronous='normal';
    PRAGMA temp_store='memory';
    PRAGMA mmap_size=100000000;
    ;

  # `main-tables` is a list of the tables to create and populate in the
  # database. These tables store data loaded from sources and some
  # derived information that does not need to be recreated before each
  # report run.
  #
  # The tables are created in the order given.
  #
  # Each one may also define an `active` and/or an `inactive` table,
  # which are both created later, but before `report-tables` below.
  #
  # Filters, when defined, act on these active/inactive temporary tables
  # during their build time.
  main-tables:
    - sources
    - sources-licence
    - reporting-updates
    - probes
    - samplers
    - ca-samplers
    - gw-samplers
    - gw-components
    - gateways
    - tokens

  # `report-tables` is a list of (temporary) tables to create for
  # reporting from the primary source data. These tables are fully
  # recreated before each report run and also if the `--post-process`
  # flag is give to `fetch` (the latter only useful for debugging, if
  # the report tables are stored on disk). If `db.temporary-table` is
  # set to empty then the data is stored in the database, useful for
  # diagnostics during report development.
  #
  # The tables are created in the order given and after any reporting
  # tables from the `main-tables` section above.
  report-tables:
    - servers

    - l1plugins-per-server
    - l1plugins-per-probe
    - l1covered-probes
    - l1covered-servers
    - l1covered-gateways

    - l2plugins-per-server
    - l2plugins-per-probe
    - l2covered-probes
    - l2covered-servers
    - l2covered-gateways

    - l3plugins-per-server
    - l3plugins-per-probe
    - l3covered-probes
    - l3covered-servers
    - l3covered-gateways

    - covered-gateways
    - unused-gateways
    - empty-gateways

    - covered-servers
    - uncovered-servers
    - empty-servers

    - covered-probes
    - empty-probes

    - match-gateways
    - match-servers
    - match-gateway-sources
    - match-sampler-plugins


  # `gdna-version` stores the version of gdna that the database was
  # created with. This will be used to perform schema updates in future
  # releases.
  gdna-version:
    table: gdna_version
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.gdna-version.table} (
        version        TEXT NOT NULL UNIQUE
      );
    insert: > #sql
      INSERT INTO ${db.gdna-version.table} (version)
        VALUES (@version)
        ON CONFLICT (version)
          DO UPDATE SET version = @version;
    query: > #sql
      SELECT version FROM ${db.gdna-version.table};

  # updates are run based on the current value of PRAGMA user_version
  #
  # each set of updates for values greater than the current value are
  # run and the value updated. each update is run in it's own
  # transaction and failure results in program termination.
  schema-updates:
    1:
      # if table already exists, then recreate it
      check: |
        SELECT count(*) BETWEEN 1 AND 4 FROM pragma_table_info('${db.gateways.table}')
      update: |
        CREATE TABLE ${db.gateways.table}_new (
          gateway           TEXT NOT NULL COLLATE NOCASE,
          firstSeen         TIMESTAMP NOT NULL,
          lastSeen          TIMESTAMP NOT NULL,
          source            TEXT NOT NULL,

          UNIQUE (gateway, source)
        );
        INSERT INTO ${db.gateways.table}_new SELECT * FROM ${db.gateways.table};
        DROP TABLE ${db.gateways.table};
        ALTER TABLE ${db.gateways.table}_new RENAME TO ${db.gateways.table};
    2:
      # if ca_samplers_all has less than the expected columns, recreate
      check: | #sql
        SELECT count(*) BETWEEN 1 AND 14 FROM pragma_table_info('${db.ca-samplers.table}');
      update: | #sql
        CREATE TABLE ${db.ca-samplers.table}_new (
          gateway           TEXT NOT NULL COLLATE NOCASE,
          plugin            TEXT NOT NULL,
          entity            TEXT,
          number            INT NOT NULL,
          probeName         TEXT COLLATE NOCASE,
          probePort         INT,
          tokenID           TEXT,
          server            TEXT COLLATE NOCASE,
          hostID            TEXT,
          os                TEXT,
          version           TEXT,
          firstSeen         TIMESTAMP NOT NULL,
          lastSeen          TIMESTAMP NOT NULL,
          source            TEXT NOT NULL,
          UNIQUE (gateway, plugin, entity)
        );
        INSERT INTO ${db.ca-samplers.table}_new
          SELECT gateway, plugin, entity, number, NULL AS probeName, NULL AS probePort, NULL AS tokenID, NULL AS server, NULL AS hostID, NULL AS os, NULL AS version, firstSeen, lastSeen, source
            FROM ${db.ca-samplers.table};
        DROP TABLE ${db.ca-samplers.table};
        ALTER TABLE ${db.ca-samplers.table}_new RENAME TO ${db.ca-samplers.table};
        CREATE INDEX ${db.ca-samplers.table}_idx1 ON ${db.ca-samplers.table} (source, lastSeen DESC);
    3:
      check: | #sql
        SELECT count(*) = 4 FROM pragma_table_info('${db.gateways.table}')
      update: | #sql
        CREATE TABLE ${db.gateways.table}_new (
          gateway           TEXT NOT NULL COLLATE NOCASE,
          gatewayHost       TEXT,
          gatewayPort       INT,
          version           TEXT,
          firstSeen         TIMESTAMP NOT NULL,
          lastSeen          TIMESTAMP NOT NULL,
          source            TEXT NOT NULL,

          UNIQUE (gateway, source)
        );
        INSERT INTO ${db.gateways.table}_new
          SELECT gateway, NULL AS gatewayHost, NULL AS gatewayPort, NULL AS version, firstSeen, lastSeen, source
            FROM ${db.gateways.table};
        DROP TABLE ${db.gateways.table};
        ALTER TABLE ${db.gateways.table}_new RENAME TO ${db.gateways.table};

  #
  # main-tables
  #

  # the sources table tracks the first and last timestamps for each
  # source we collect data for.
  #
  # this is used for both reporting about sources but also to check if
  # the reporting database needs rebuilding
  #
  # sources are always unfiltered
  sources:
    table: sources
    columns: source, status, firstSeen, lastSeen, sourceType, path, valid
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.sources.table} (
        source            TEXT NOT NULL UNIQUE,
        status            TEXT NOT NULL,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        sourceType        TEXT NOT NULL,
        path              TEXT NOT NULL,
        valid             BOOL
      );
    insert: > #sql
      INSERT INTO ${db.sources.table}
               (source, status, sourceType, firstSeen, lastSeen, path, valid)
        VALUES (@source, @status, @sourceType, @firstSeen, @lastSeen, @path, @valid)
      ON CONFLICT (source)
        DO UPDATE SET sourceType=@sourceType, path=@path, lastSeen=@lastSeen, status=@status, valid=@valid;

    update-valid: > #sql
      UPDATE ${db.sources.table} SET
          valid = unixepoch(lastSeen) >= @oldestValidTime AND source IN (${sources}),
          status = 
            CASE WHEN unixepoch(lastSeen) < @oldestValidTime AND status = "OK"
                  THEN "STALE: Not updated for more than " ||@maxAge
                WHEN unixepoch(lastSeen) >= @oldestValidTime AND status like 'STALE%'
                  THEN "OK"
                ELSE status
                END;

  # sources-licence is always unfiltered
  sources-licence:
    table: sources_licence
    columns: source, status, firstSeen, lastSeen, sourceType, path, valid
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.sources-licence.table} (
        source            TEXT NOT NULL UNIQUE,
        licenceexpiry     TIMESTAMP,
        licencemode       TEXT,
        licencename       TEXT,
        hostname          TEXT,
        hostid            TEXT
      );
    insert: | #sql
      INSERT INTO ${db.sources-licence.table}
              (source, licenceexpiry, licencemode, licencename, hostname, hostid)
        VALUES (@source, @licenceexpiry, @licencemode, @licencename, @hostname, @hostid)
      ON CONFLICT (source)
        DO UPDATE SET licenceexpiry=@licenceexpiry, licencemode=@licencemode, licencename=@licencename, hostname=@hostname, hostid=@hostid;

  # `reporting-updates` stores the time of the latest time from the last
  # fetch run. It cannot be a temporary table as it stores historical
  # data
  reporting-updates:
    table: reporting_updates
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.reporting-updates.table} (
        lastUpdate        TIMESTAMP NOT NULL
      );
    update: > #sql
      DELETE FROM ${db.reporting-updates.table};
      INSERT INTO ${db.reporting-updates.table} SELECT COALESCE(max(lastSeen), 'now') FROM ${db.sources.table};

  # the probes table contains entries for all netprobes, where
  # component = "binary" and item = "netprobe"
  probes:
    table: probes_all
    columns: gateway, probeName, probePort, server, hostID, firstSeen, lastSeen, source, os, version
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.probes.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        probeName         TEXT COLLATE NOCASE,
        probePort         INT,
        tokenID           TEXT,
        server            TEXT COLLATE NOCASE,
        hostID            TEXT,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        os                TEXT,
        version           TEXT,
        UNIQUE (gateway, probeName, probePort, tokenID)
      );
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx1 ON ${db.probes.table} (source, lastSeen DESC);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx2 ON ${db.probes.table} (gateway, tokenID, probeName);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx3 ON ${db.probes.table} (gateway, tokenID, probeName DESC);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx4 ON ${db.probes.table} (tokenID, probeName DESC);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx5 ON ${db.probes.table} (probeName);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx6 ON ${db.probes.table} (server);
    insert: > #sql
      INSERT INTO ${db.probes.table}
               (gateway, probeName, probePort, tokenID, firstSeen, lastSeen, source, os, version)
        VALUES (@gateway, @probeName, @probePort, @tokenID, @time, @time, @source, @os, @version)
        ON CONFLICT (gateway, probeName, probePort, tokenID)
          DO UPDATE SET lastSeen=@time, source=@source, os=COALESCE(@os, os), version=COALESCE(@version, version);
    # NOTE: we append the hostid so that multiple containers on the same host are distinguished
    post-insert: > #sql
      UPDATE ${db.probes.table} AS p
         SET hostID = tokenID,
             server = (SELECT lower(probeName)
                         FROM ${db.probes.table}
                        WHERE tokenID = p.tokenID
                        ORDER BY lower(probeName) IN ('localhost', '127.0.0.1'), probeName DESC
                       LIMIT 1)
                      || ':' || tokenID;
    active: probes
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.probes.active};
      CREATE ${db.temporary-table} TABLE ${db.probes.active} AS
        SELECT ${db.probes.columns}
          FROM ${db.probes.table} p
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = p.source AND valid)
           AND ${filters:p:gateway,source,server,hostid}
        ;
      CREATE INDEX IF NOT EXISTS ${db.probes.active}_idx1 ON ${db.probes.active} (server);

    inactive: probes_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.probes.inactive};
      CREATE ${db.temporary-table} TABLE ${db.probes.inactive} AS
        SELECT ${db.probes.columns}
          FROM ${db.probes.table} p
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = p.source AND valid)
           AND ${filters:p:gateway,source,server,hostid}
        ;

  samplers:
    # The samplers table contains all entries from the license daemon for
    # the "plugin" component, the plugin column being set to the "item"
    table: samplers_all
    columns: gateway, plugin, probeName, probePort, server, hostID, number, source, individual, firstSeen, lastSeen
    # the indexes below were suggested by SQLite ".expert" mode during
    # development and may need to be updated based on changes since
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.samplers.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        plugin            TEXT NOT NULL,
        probeName         TEXT COLLATE NOCASE,
        probePort         INT,
        tokenID           TEXT,
        hostID            TEXT,
        individual        BOOLEAN,
        server            TEXT COLLATE NOCASE,
        number            INT NOT NULL,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        UNIQUE (gateway, plugin, probeName, probePort, tokenID, lastSeen),
        UNIQUE (gateway, plugin, probeName, probePort, tokenID)
      );
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx1 ON ${db.samplers.table} (source, lastSeen DESC);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx2 ON ${db.samplers.table} (gateway, server, tokenID);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx3 ON ${db.samplers.table} (server, tokenID);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx4 ON ${db.samplers.table} (tokenID, probeName DESC);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx5 ON ${db.samplers.table} (gateway, tokenID, probeName);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx6 ON ${db.samplers.table} (probeName, gateway, server);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx7 ON ${db.samplers.table} (server, plugin);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx8 ON ${db.samplers.table} (probeName, probePort, plugin);
    insert: | #sql
      INSERT INTO ${db.samplers.table}
             (gateway, plugin, probeName, probePort, tokenID, number, individual, firstSeen, lastSeen, source)
      VALUES (@gateway, @plugin, @probeName, @probePort, @tokenID, @number, @individual, @time, @time, @source)
        ON CONFLICT (gateway, plugin, probeName, probePort, tokenID, lastSeen)
          DO UPDATE SET number=number+@number WHERE hostID IS NULL
        ON CONFLICT (gateway, plugin, probeName, probePort, tokenID)
          DO UPDATE SET number=@number, source=@source, lastSeen=@time, hostID=NULL;
    post-insert: | #sql
      UPDATE ${db.samplers.table} AS s
         SET server = (SELECT server
                         FROM ${db.probes.table}
                        WHERE gateway = s.gateway
                          AND probeName = s.probeName
                          AND probePort = s.probePort
                        ORDER BY lastSeen DESC
                        LIMIT 1),
             hostID = IIF(tokenID <> 'INDIVIDUAL',
                          tokenID,
                          (SELECT tokenID
                             FROM ${db.samplers.table}
                            WHERE (gateway, probeName) IN (SELECT DISTINCT gateway, probeName FROM ${db.samplers.table} WHERE tokenID <> 'INDIVIDUAL')
                              AND probeName = s.probeName
                              AND tokenID <> 'INDIVIDUAL'
                            LIMIT 1)
                         ),
             individual = IIF(tokenID = 'INDIVIDUAL', 1, NULL)
      ;
      -- ensure hostID is always set, even if the the subquery returns NULL - but use the final server name
      UPDATE ${db.samplers.table}
         SET hostID = server
       WHERE hostID IS NULL
      ;
    active: samplers
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.samplers.active};
      CREATE ${db.temporary-table} TABLE ${db.samplers.active} AS
        SELECT ${db.samplers.columns}
          FROM ${db.samplers.table} s
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = s.source AND valid)
           AND ${filters:s:gateway,source,server,plugin,hostid}
      ;
      CREATE INDEX IF NOT EXISTS ${db.samplers.active}_idx_1 ON ${db.samplers.active} (server);
      CREATE INDEX IF NOT EXISTS ${db.samplers.active}_idx_2 ON ${db.samplers.active} (probeName, probePort);
      CREATE INDEX IF NOT EXISTS ${db.samplers.active}_idx_3 ON ${db.samplers.active} (server, plugin);
      CREATE INDEX IF NOT EXISTS ${db.samplers.active}_idx_4 ON ${db.samplers.active} (gateway, probeName, probePort, plugin);

    inactive: samplers_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.samplers.inactive};
      CREATE ${db.temporary-table} TABLE ${db.samplers.inactive} AS
        SELECT ${db.samplers.columns}
          FROM ${db.samplers.table} s
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = s.source AND valid)
           AND ${filters:s:gateway,source,server,plugin,hostid}

      ;

  ca-samplers:
    # The ca-samplers table contains all entries from the license daemon for
    # the "ca-plugin" component, the plugin column being set to the "item"
    table: ca_samplers_all
    columns: gateway, plugin, entity, number, probeName, probePort, server, hostID, firstSeen, lastSeen, source
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.ca-samplers.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        plugin            TEXT NOT NULL,
        entity            TEXT,
        number            INT NOT NULL,
        probeName         TEXT COLLATE NOCASE,
        probePort         INT,
        tokenID           TEXT,
        server            TEXT COLLATE NOCASE,
        hostID            TEXT,
        os                TEXT,
        version           TEXT,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        UNIQUE (gateway, plugin, entity)
      );
      CREATE INDEX IF NOT EXISTS ${db.ca-samplers.table}_idx1 ON ${db.ca-samplers.table} (source, lastSeen DESC);
    insert: > #sql
      INSERT INTO ${db.ca-samplers.table}
               (gateway, plugin, entity, probeName, probePort, tokenID, hostID, number, firstSeen, lastSeen, source)
        VALUES (@gateway, @plugin, @entity, @probeName, @probePort, @tokenID, @tokenID, @number, @time, @time, @source)
        ON CONFLICT (gateway, plugin, entity)
          DO UPDATE SET number=@number, source=@source, lastSeen=@time, probeName=@probeName, probePort=@probePort, tokenID=@tokenID, hostID=@tokenID;
    post-insert: > #sql
      UPDATE ${db.ca-samplers.table} AS s
         SET server = (SELECT server
                         FROM ${db.probes.table}
                        WHERE gateway = s.gateway
                          AND probeName = s.probeName
                          AND probePort = s.probePort
                        ORDER BY lastSeen DESC
                        LIMIT 1)
      ;

    active: ca_samplers
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.ca-samplers.active};
      CREATE ${db.temporary-table} TABLE ${db.ca-samplers.active} AS
        SELECT ${db.ca-samplers.columns}
          FROM ${db.ca-samplers.table} c
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = c.source AND valid)
           AND ${filters:c:gateway,source,server,plugin,hostid}
      ;
      CREATE INDEX IF NOT EXISTS ${db.ca-samplers.active}_idx_1 ON ${db.ca-samplers.active} (server, plugin);
      CREATE INDEX IF NOT EXISTS ${db.ca-samplers.active}_idx_2 ON ${db.ca-samplers.active} (gateway, probeName, probePort, plugin);
    inactive: ca_samplers_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.ca-samplers.inactive};
      CREATE ${db.temporary-table} TABLE ${db.ca-samplers.inactive} AS
        SELECT ${db.ca-samplers.columns}
          FROM ${db.ca-samplers.table} c
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = c.source AND valid)
           AND ${filters:c:gateway,source,server,plugin,hostid}
      ;

  gw-samplers:
    # The `gw-samplers` table contains all entries from the license
    # daemon for the "gateway-plugin" component, the plugin column
    # being set to the "item"
    table: gw_samplers_all
    columns: gateway, plugin, number, firstSeen, lastSeen, source
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.gw-samplers.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        plugin            TEXT NOT NULL,
        number            INT NOT NULL,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        UNIQUE (gateway, plugin)
      );
      CREATE INDEX IF NOT EXISTS ${db.gw-samplers.table}_idx1 ON ${db.gw-samplers.table} (source, lastSeen DESC);
    insert: > #sql
      INSERT INTO ${db.gw-samplers.table}
               (gateway, plugin, number, firstSeen, lastSeen, source)
        VALUES (@gateway, @plugin, @number, @time, @time, @source)
        ON CONFLICT (gateway, plugin)
          DO UPDATE SET number=@number, source=@source, lastSeen=@time;
    active: gw_samplers
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.gw-samplers.active};
      CREATE ${db.temporary-table} TABLE ${db.gw-samplers.active} AS
        SELECT ${db.gw-samplers.columns}
          FROM ${db.gw-samplers.table} s
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = s.source AND valid)
           AND ${filters:s:gateway,source,plugin}
      ;
    inactive: gw_samplers_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.gw-samplers.inactive};
      CREATE ${db.temporary-table} TABLE ${db.gw-samplers.inactive} AS
        SELECT ${db.gw-samplers.columns}
          FROM ${db.gw-samplers.table} s
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = s.source AND valid)
           AND ${filters:s:gateway,source,plugin}
      ;

  gw-components:
    # The `gw-components` table contains all entries from the license
    # daemon for the "gateway_component" component, the plugin column
    # being set to the "item"
    table: gw_components_all
    columns: gateway, component, number, firstSeen, lastSeen, source
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.gw-components.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        component         TEXT NOT NULL,
        number            INT NOT NULL,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        UNIQUE (gateway, component)
      );
      CREATE INDEX IF NOT EXISTS ${db.gw-components.table}_idx1 ON ${db.gw-components.table} (source, lastSeen DESC);
    insert: > #sql
      INSERT INTO ${db.gw-components.table}
               (gateway, component, number, firstSeen, lastSeen, source)
        VALUES (@gateway, @component, @number, @time, @time, @source)
        ON CONFLICT (gateway, component)
          DO UPDATE SET number=@number, source=@source, lastSeen=@time;
    active: gw_components
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.gw-components.active};
      CREATE ${db.temporary-table} TABLE ${db.gw-components.active} AS
        SELECT ${db.gw-components.columns}
          FROM ${db.gw-components.table} gwc 
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = gwc.source AND valid)
           AND ${filters:gwc:gateway,source}
      ;
    inactive: gw_components_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.gw-components.inactive};
      CREATE ${db.temporary-table} TABLE ${db.gw-components.inactive} AS
        SELECT ${db.gw-components.columns}
          FROM ${db.gw-components.table} gwc
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = gwc.source AND valid)
           AND ${filters:gwc:gateway,source}
      ;

  # gateways returns a single column table containing all known gateways
  # from the four samplers and probes tables
  gateways:
    table: gateways_all
    columns: gateway, gatewayHost, gatewayPort, version, firstSeen, lastSeen, source
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.gateways.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        gatewayHost       TEXT,
        gatewayPort       INT,
        version           TEXT,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,

        UNIQUE (gateway, source)
      );

    insert: > #sql
      INSERT INTO ${db.gateways.table}
              (gateway, gatewayHost, gatewayPort, version, firstSeen, lastSeen, source)
      VALUES (@gateway, @host, @port, @version, @time, @time, @source)
      ON CONFLICT (gateway, source)
        DO UPDATE SET gatewayHost=@host, gatewayPort=@port, version=@version, lastSeen=@time, source=@source
      ;
    filter:
      # include MUST default to a wildcard
      include: "*"
      # exclude MUST default to nothing
      exclude:
    active: gateways
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.gateways.active};
      CREATE TABLE ${db.gateways.active} AS
        SELECT gateway, gatewayHost, gatewayPort, version, min(firstSeen) as firstSeen, max(lastSeen) as lastSeen, group_concat(source, ',') as source
          FROM ${db.gateways.table} gw
        WHERE gateway IN (
            SELECT distinct gateway AS gateway FROM ${db.samplers.active}
            UNION
            SELECT distinct gateway AS gateway FROM ${db.ca-samplers.active}
            UNION
            SELECT distinct gateway AS gateway FROM ${db.gw-samplers.active}
            UNION
            SELECT distinct gateway AS gateway FROM ${db.probes.active}
          )
          AND lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = gw.source AND valid)
          AND ${filters:gw:gateway,source}
          GROUP BY gateway
      ;
    inactive: gateways_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.gateways.inactive};
      CREATE TABLE ${db.gateways.inactive} AS
        SELECT gateway, gatewayHost, gatewayPort, version, min(firstSeen) as firstSeen, max(lastSeen) as lastSeen, group_concat(source, ',') as source
          FROM ${db.gateways.table} gw
        WHERE gateway IN (
            SELECT distinct gateway AS gateway FROM ${db.samplers.active}
            UNION
            SELECT distinct gateway AS gateway FROM ${db.ca-samplers.active}
            UNION
            SELECT distinct gateway AS gateway FROM ${db.gw-samplers.active}
            UNION
            SELECT distinct gateway AS gateway FROM ${db.probes.active}
          )
          AND lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = gw.source AND valid)
          AND ${filters:gw:gateway,source}
          GROUP BY gateway
      ;

  tokens:
    table: tokens_all
    columns: token, total, used, free, firstSeen, lastSeen, source
    create: | #sql
      CREATE TABLE IF NOT EXISTS ${db.tokens.table} (
        token             TEXT NOT NULL,
        total             NUMBER,
        used              NUMBER,
        free              NUMBER,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,

        UNIQUE (token, source)
      );
    insert: | #sql
      INSERT INTO ${db.tokens.table}
                  (token, total, used, free, firstSeen, lastSeen, source)
      VALUES (@token, @total, @used, @free, @time, @time, @source)
      ON CONFLICT (token, source)
        DO UPDATE SET total=@total, used=@used, free=@free, lastSeen=@time;
      ;
    active: tokens
    create-active: | #sql
      DROP TABLE IF EXISTS ${db.tokens.active};
      CREATE TABLE ${db.tokens.active} AS
        SELECT DISTINCT token, total, used, free, t.firstSeen firstSeen, t.lastSeen lastSeen, t.source source -- ${db.tokens.columns}
          FROM ${db.tokens.table} t, ${db.sources.table} s
         WHERE t.lastSeen = s.lastSeen AND s.valid = 1
      ;

  #
  # report-tables
  #

  # report tables have filters applied in the source tables they query.
  # Make sure that all source tables used "active" and not "table" in
  # the identifier, when they exist.

  # The `servers` table is built from the probes on all valid sources
  # grouped by gateway and source. The server name is resolved in the
  # `db.probes.post-insert` query which is run after all probes are
  # loaded.
  servers:
    table: servers
    columns: gateway, server, hostID, firstSeen, lastSeen, source, os, version
    create: > #sql
      DROP TABLE IF EXISTS ${db.servers.table};
      CREATE ${db.temporary-table} TABLE ${db.servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.probes.active}
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = ${db.probes.active}.source AND valid)
         GROUP BY gateway, server
      ;
      CREATE INDEX IF NOT EXISTS ${db.servers.table}_idx_1 ON ${db.servers.table}(server, gateway);
      CREATE INDEX IF NOT EXISTS ${db.servers.table}_idx_2 ON ${db.servers.table}(gateway, server);

  # the `l1plugins-per-server` table is built from all active samplers
  # that match the plugin names in the `level1` table and is then
  # grouped by gateway, server and plugin.
  l1plugins-per-server:
    table: l1_plugins_server
    columns: gateway, plugin, server, hostID, number, source, individual, firstSeen, lastSeen
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1plugins-per-server.table};
      CREATE ${db.temporary-table} TABLE ${db.l1plugins-per-server.table} AS
        SELECT gateway, plugin, server, hostID, sum(number) as number, source, individual, firstSeen, lastSeen
          FROM ${db.samplers.active}
        WHERE plugin IN ${plugins.level1.table}
        GROUP BY gateway, server, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l1plugins-per-server.table}_idx_1 ON ${db.l1plugins-per-server.table}(server);

  # the `l1plugins-per-probe` table is built from all active samplers
  # that match the plugin names in the `level1` table and is then
  # grouped by gateway, probeName, probePort and plugin.
  l1plugins-per-probe:
    table: l1_plugins_probe
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1plugins-per-probe.table};
      CREATE ${db.temporary-table} TABLE ${db.l1plugins-per-probe.table} AS
        SELECT ${db.samplers.columns}
          FROM ${db.samplers.active}
        WHERE plugin IN ${plugins.level1.table}
        GROUP BY gateway, probeName, probePort, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l1plugins-per-probe.table}_idx_1 ON ${db.l1plugins-per-probe.table}(probeName, probePort);

  # the `l1covered-*` tables are built from active probes / samplers /
  # gateways where the number of distinct plugins match the number in
  # the `level1` table. Each is grouped by gateway and then either the
  # probe host & port or server, as appropriate.

  l1covered-probes:
    table: l1covered_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1covered-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.l1covered-probes.table} AS
      SELECT ${db.probes.columns}
        FROM ${db.probes.active}
       WHERE (probeName, probePort) IN (
        SELECT probeName, probePort
          FROM ${db.l1plugins-per-probe.table}
         GROUP BY probeName, probePort
        HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level1.table})
       )
       GROUP BY gateway, probeName, probePort;

  l1covered-servers:
    table: l1covered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1covered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.l1covered-servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
        WHERE server IN (
            SELECT server
              FROM ${db.l1plugins-per-server.table}
            GROUP BY server
            HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level1.table})
        )
        GROUP BY gateway, server;
        CREATE INDEX IF NOT EXISTS ${db.l1covered-servers.table}_idx_1 ON ${db.l1covered-servers.table}(gateway);


  l1covered-gateways:
    table: l1covered_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1covered-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.l1covered-gateways.table} AS
      SELECT ${db.gateways.columns}
        FROM ${db.gateways.active}
        WHERE gateway IN (
          SELECT gateway FROM (
            SELECT gateway
              FROM ${db.l1plugins-per-server.table}
              GROUP BY gateway, server
            HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level1.table})
          ) AS l1a
           GROUP BY gateway
          HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} p WHERE p.gateway = l1a.gateway)
        )
        GROUP BY gateway;

  l2plugins-per-server:
    table: l2_plugins_server
    columns: gateway, plugin, server, hostID, number, source, individual, firstSeen, lastSeen
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2plugins-per-server.table};
      CREATE ${db.temporary-table} TABLE ${db.l2plugins-per-server.table} AS
        SELECT gateway, plugin, server, hostID, sum(number) as number, source, individual, firstSeen, lastSeen
          FROM ${db.samplers.active}
        WHERE plugin IN ${plugins.level2.table}
        GROUP BY gateway, server, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l2plugins-per-server.table}_idx_1 ON ${db.l2plugins-per-server.table}(server);

  l2plugins-per-probe:
    table: l2_plugins_probe
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2plugins-per-probe.table};
      CREATE ${db.temporary-table} TABLE ${db.l2plugins-per-probe.table} AS
        SELECT ${db.samplers.columns}
          FROM ${db.samplers.active}
        WHERE plugin IN ${plugins.level2.table}
        GROUP BY gateway, probeName, probePort, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l2plugins-per-probe.table}_idx_1 ON ${db.l2plugins-per-probe.table}(probeName, probePort);

  l2covered-probes:
    table: l2covered_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2covered-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.l2covered-probes.table} AS
      SELECT ${db.probes.columns}
        FROM ${db.probes.active}
       WHERE (probeName, probePort) IN (
        SELECT probeName, probePort
          FROM ${db.l2plugins-per-probe.table}
         GROUP BY probeName, probePort
        HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level2.table})
       )
       GROUP BY gateway, probeName, probePort;

  l2covered-servers:
    table: l2covered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2covered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.l2covered-servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
        WHERE server IN (
          SELECT server
            FROM ${db.l2plugins-per-server.table}
          GROUP BY server
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level2.table})
        )
        GROUP BY gateway, server;
      CREATE INDEX IF NOT EXISTS ${db.l2covered-servers.table}_idx_1 ON ${db.l2covered-servers.table}(gateway);

  l2covered-gateways:
    table: l2covered_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2covered-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.l2covered-gateways.table} AS
      SELECT ${db.gateways.columns}
        FROM ${db.gateways.active}
        WHERE gateway IN (
          SELECT gateway FROM (
            SELECT gateway
              FROM ${db.l2plugins-per-server.table}
              GROUP BY gateway, server
            HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level2.table})
          ) AS l2a
            GROUP BY gateway
          HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} WHERE gateway = l2a.gateway)
        )
        GROUP BY gateway;

  l3plugins-per-server:
    table: l3_plugins_server
    columns: gateway, plugin, server, hostID, number, source, individual, firstSeen, lastSeen
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3plugins-per-server.table};
      CREATE ${db.temporary-table} TABLE ${db.l3plugins-per-server.table} AS
        SELECT gateway, plugin, server, hostID, sum(number) as number, source, individual, firstSeen, lastSeen
          FROM ${db.samplers.active}
        WHERE plugin NOT IN ${plugins.level1.table}
          AND plugin NOT IN ${plugins.level1-optional.table}
          AND plugin NOT IN ${plugins.level2.table}
        GROUP BY gateway, server, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l3plugins-per-server.table}_idx_1 ON ${db.l3plugins-per-server.table}(server);

  l3plugins-per-probe:
    table: l3_plugins_probe
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3plugins-per-probe.table};
      CREATE ${db.temporary-table} TABLE ${db.l3plugins-per-probe.table} AS
        SELECT ${db.samplers.columns}
          FROM ${db.samplers.active}
        WHERE plugin NOT IN ${plugins.level1.table}
          AND plugin NOT IN ${plugins.level1-optional.table}
          AND plugin NOT IN ${plugins.level2.table}
        GROUP BY gateway, probeName, probePort, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l3plugins-per-probe.table}_idx_2 ON ${db.l3plugins-per-probe.table}(probeName, probePort);

  l3covered-probes:
    table: l3covered_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3covered-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.l3covered-probes.table} AS
      SELECT ${db.probes.columns}
        FROM ${db.probes.active}
       WHERE (probeName, probePort) IN (SELECT DISTINCT probeName, probePort FROM ${db.l3plugins-per-probe.table})
       GROUP BY gateway, probeName, probePort;

  l3covered-servers:
    table: l3covered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3covered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.l3covered-servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
        WHERE server IN (SELECT server FROM ${db.l3plugins-per-server.table} GROUP BY server)
        GROUP BY gateway, server;
      CREATE INDEX IF NOT EXISTS ${db.l3covered-servers.table}_idx_1 ON ${db.l3covered-servers.table}(gateway);

  l3covered-gateways:
    table: l3covered_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3covered-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.l3covered-gateways.table} AS
      SELECT ${db.gateways.columns}
        FROM ${db.gateways.active}
       WHERE gateway IN (
          SELECT gateway FROM (
            SELECT gateway
              FROM ${db.l3plugins-per-server.table}
              GROUP BY gateway, server
          ) AS l3a
            GROUP BY gateway
          HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} WHERE gateway = l3a.gateway)
       )
       GROUP BY gateway;

  covered-gateways:
    table: covered_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.covered-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.covered-gateways.table} AS
      WITH
      l1 AS (
        SELECT gateway FROM (
          SELECT gateway
            FROM ${db.l1plugins-per-server.table}
          GROUP BY gateway, server
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level1.table})
        ) AS l1a
        GROUP BY gateway
        HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} p WHERE p.gateway = l1a.gateway)
      ), l2 AS (
        SELECT gateway FROM (
          SELECT gateway
            FROM ${db.l2plugins-per-server.table}
          GROUP BY gateway, server
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level2.table})
        ) AS l2
        GROUP BY gateway
        HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} p WHERE p.gateway = l2.gateway)
      ), l3 AS (
        SELECT gateway FROM (
          SELECT gateway
            FROM ${db.l3plugins-per-server.table}
            GROUP BY gateway, server
        ) as l3
        GROUP BY gateway
        HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} p WHERE p.gateway = l3.gateway)
      )
      SELECT ${db.gateways.columns}
        FROM ${db.gateways.active}
        WHERE gateway IN l1 AND gateway IN l2 AND gateway IN l3
       GROUP BY gateway
      HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} p WHERE p.gateway = ${db.gateways.active}.gateway);

  empty-gateways:
    table: empty_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.empty-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.empty-gateways.table} AS
      SELECT gateway, min(firstSeen) as firstSeen, max(lastSeen) as lastSeen, group_concat(source, ',') as source
        FROM ${db.gateways.active}
        WHERE gateway NOT IN (SELECT distinct gateway FROM ${db.samplers.active})
          AND gateway NOT IN (SELECT distinct gateway FROM ${db.ca-samplers.active})
          AND gateway NOT IN (SELECT distinct gateway FROM ${db.gw-samplers.active})
        GROUP BY gateway;

  # `unused-gateways` includes all gateways that are not referenced by
  # an active server
  unused-gateways:
    table: unused_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.unused-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.unused-gateways.table} AS
      SELECT gateway, min(firstSeen) as firstSeen, max(lastSeen) as lastSeen, group_concat(source, ',') as source
        FROM ${db.gateways.active}
       WHERE gateway NOT IN (SELECT distinct gateway FROM ${db.servers.table})
         AND gateway NOT IN (SELECT distinct gateway FROM ${db.samplers.active})
         AND gateway NOT IN (SELECT distinct gateway FROM ${db.ca-samplers.active})
         AND gateway NOT IN (SELECT distinct gateway FROM ${db.gw-samplers.active})
       GROUP BY gateway;

  covered-servers:
    table: covered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.covered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.covered-servers.table} AS
        WITH
        l1 AS (
          SELECT server
            FROM ${db.l1plugins-per-server.table}
            GROUP BY server
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level1.table})
        ), l2 AS (
          SELECT server
            FROM ${db.l2plugins-per-server.table}
            GROUP BY server
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level2.table})
        ), l3 AS (
          SELECT server
            FROM ${db.l3plugins-per-server.table}
            GROUP BY server
        )
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
          WHERE server IN l1
            AND server IN l2
            AND server IN l3;

  uncovered-servers:
    table: uncovered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.uncovered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.uncovered-servers.table} AS
        WITH
        l1 AS (
          SELECT server
            FROM ${db.l1plugins-per-server.table}
            GROUP BY server
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level1.table})
        ), l2 AS (
          SELECT server
            FROM ${db.l2plugins-per-server.table}
            GROUP BY server
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level2.table})
        ), l3 AS (
          SELECT server
            FROM ${db.l3plugins-per-server.table}
            GROUP BY server
        )
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
         WHERE server NOT IN l1
            OR server NOT IN l2
            OR server NOT IN l3;
        CREATE INDEX IF NOT EXISTS ${db.uncovered-servers.table}_idx_1 ON ${db.uncovered-servers.table}(server);

  empty-servers:
    table: empty_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.empty-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.empty-servers.table} AS
      SELECT ${db.servers.columns}
        FROM ${db.servers.table}
        WHERE server NOT IN (SELECT server FROM ${db.samplers.active})
          AND server NOT IN (SELECT server FROM ${db.ca-samplers.active});

  covered-probes:
    table: covered_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.covered-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.covered-probes.table} AS
        WITH
        l1 AS (
          SELECT probeName, probePort
            FROM ${db.l1plugins-per-probe.table}
            GROUP BY probeName, probePort
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level1.table})
        ), l2 AS (
          SELECT probeName, probePort
            FROM ${db.l2plugins-per-probe.table}
            GROUP BY probeName, probePort
          HAVING count(distinct plugin) = (SELECT count(*) FROM ${plugins.level2.table})
        ), l3 AS (
          SELECT probeName, probePort
            FROM ${db.l3plugins-per-probe.table}
            GROUP BY probeName, probePort
        )
        SELECT ${db.probes.columns}
          FROM ${db.probes.active}
          WHERE (probeName, probePort) IN l1
            AND (probeName, probePort) IN l2
            AND (probeName, probePort) IN l3;

  empty-probes:
    table: empty_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.empty-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.empty-probes.table} AS
      SELECT ${db.probes.columns}
        FROM ${db.probes.active}
        WHERE (probeName, probePort) NOT IN (SELECT probeName, probePort FROM ${db.samplers.active});

  # the `match` tables, used to join to queries for grouping

  match-gateways:
    table: match_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.match-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.match-gateways.table} AS
        SELECT DISTINCT grouping, gw.gateway
          FROM ${filters.groups.gateway.table} grouping
          LEFT JOIN ${db.gateways.active} gw ON glob(grouping.gateway, gw.gateway);

  match-servers:
    table: match_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.match-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.match-servers.table} AS
        SELECT DISTINCT grouping, srv.server
          FROM ${filters.groups.server.table} grouping
          LEFT JOIN ${db.servers.table} srv ON glob(grouping.server, srv.server);

  match-gateway-sources:
    table: match_gateway_sources
    create: > #sql
      DROP TABLE IF EXISTS ${db.match-gateway-sources.table};
      CREATE ${db.temporary-table} TABLE ${db.match-gateway-sources.table} AS
        SELECT DISTINCT grouping, gw.source
          FROM ${filters.groups.source.table} grouping
          LEFT JOIN ${db.gateways.active} gw ON glob(grouping.source, gw.source);

  match-sampler-plugins:
    table: match_sampler_plugins
    create: > #sql
      DROP TABLE IF EXISTS ${db.match-sampler-plugins.table};
      CREATE ${db.temporary-table} TABLE ${db.match-sampler-plugins.table} AS
        SELECT grouping, COALESCE(s.plugin, c.plugin, g.plugin) plugin
            FROM ${filters.groups.plugin.table} grouping
            LEFT JOIN ${db.samplers.table} s ON glob(grouping.plugin, s.plugin)
            LEFT JOIN ${db.ca-samplers.table} c ON glob(grouping.plugin, c.plugin)
            LEFT JOIN ${db.gw-samplers.table} g ON glob(grouping.plugin, g.plugin)
          GROUP BY grouping, COALESCE(s.plugin, c.plugin, g.plugin, "")
      ;

# plugins is a list of the tables to create for levels of plugin
# coverage.
plugins:
  all:
    table: all_plugins
    create: | #sql
      CREATE TABLE IF NOT EXISTS ${plugins.all.table} (
        plugin            TEXT UNIQUE ON CONFLICT IGNORE NOT NULL
      );
    plugins:
      - alerting
      - api
      - api-streams
      - aws-plugin
      - azure-plugin
      - bloomberg-bpipe
      - clearvision-status
      - compute-engine
      - control-m
      - cpu
      - desktop-pc-monitoring
      - deviceio
      - disk
      - dynamic-entities-health
      - e4jms-bridges
      - e4jms-connections
      - e4jms-durables
      - e4jms-non-durables
      - e4jms-queues
      - e4jms-routes
      - e4jms-server
      - e4jms-topics
      - e4jms-usersummary
      - extractor
      - fidessa
      - fidessa-dq
      - fix-analyser2
      - fkm
      - flm
      - floating-probes
      - fluentdforward-plugin
      - ftm
      - gcp-plugin
      - gl-router
      - hardware
      - ibmi-file-member
      - ibmi-jdbc
      - ibmi-job
      - ibmi-logreader
      - ibmi-member-record
      - ibmi-message
      - ibmi-pool
      - ibmi-queue
      - ibmi-subsystem
      - ibmi-system
      - ipc
      - ix-ma
      - jdbc-plugin
      - jmx-server
      - jmx-threadinfo
      - kafka-plugin
      - kubernetes-plugin
      - market-data-monitor
      - message-tracker
      - mibmon
      - mongodb-plugin
      - mq-channel
      - mq-qinfo
      - mq-queue
      - net-ping
      - network
      - nyxt-papastats
      - op5monitor
      - opentelemetry-plugin
      - oracle
      - orc
      - perfmon
      - postgres-plugin
      - processes
      - prometheus-plugin
      - prometheus-target-plugin
      - publisher
      - reporting
      - rest-api
      - rest-extractor
      - rmc-interface
      - self-announcing-probes
      - sql-toolkit
      - statetracker
      - statsd-plugin
      - sybase
      - sybase-server
      - system-plugin
      - tcp-links
      - tib-rv
      - tib-rvpublisher
      - tib-rvstream
      - toolkit
      - top
      - trading-technologies
      - trapmon
      - unix-users
      - uptrends
      - veritas-cluster-server
      - web-mon
      - winapps
      - win-cluster
      - win-services
      - wmi
      - wts-licenses
      - wts-processes
      - wts-sessions
      - wts-summary
      - x-broadcast
      - x-mcast
      - x-multicast
      - x-ping
      - x-route
      - x-services
      - x-top
      - x-traffic
      - zookeeper-plugin

  # level1 is basic hardware / infrastructure
  #
  # there are actively four mandatory plugins and a number of
  # optional plugins. the optional plugins play no part in deciding if
  # a probe or gateway is covered for level 1 but are instead are used
  # to remove those plugins from the level 3 tests further below.
  level1:
    table: level1_plugins
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${plugins.level1.table} (
        plugin            TEXT UNIQUE ON CONFLICT IGNORE NOT NULL
      );
    plugins: [ cpu, disk, network, hardware ]

  level1-optional:
    table: level1_optional_plugins
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${plugins.level1-optional.table} (
        plugin            TEXT UNIQUE ON CONFLICT IGNORE NOT NULL
      );
    plugins: [ deviceio, ipc, top, unix-users, winapps, win-cluster, win-services, wmi, wts-licenses, wts-processes, wts-sessions, wts-summary ]

  # level 2 plugins are actively fkm (logs) and processes
  level2:
    table: level2_plugins
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${plugins.level2.table} (
        plugin            TEXT UNIQUE ON CONFLICT IGNORE NOT NULL
      );
    plugins: [ fkm, processes ]

reports:
  # This is the Summary sheet at the start of any XLSX file and as a
  # table in the body of emails. Put any required headlines here as they
  # are not added to individual sheets in an XLSX workbook.
  gdna-summary:
    group: GDNA Information
    name: GDNA Summary
    columns: [ Item, Description ]
    type: summary
    query: > #sql
      SELECT 'ITRS GDNA', 'Version ${gdna.version}'

      UNION ALL

      SELECT 'Site', '${gdna.site-name}'

      UNION ALL

      SELECT 'Report Time', '${datetime}'

      UNION ALL

      SELECT 'Created On', '${hostname}'

      UNION ALL
      
      SELECT 'Created By', '${username}'

      UNION ALL

      SELECT 'Valid/OK Licence Sources', (SELECT count(*) FROM ${db.sources.table} WHERE valid AND status = 'OK')

      UNION ALL

      SELECT 'Gateways', (SELECT count(*) FROM ${db.gateways.active}) || " (" || (SELECT count(*) FROM ${db.gateways.table}) || ")"

      UNION ALL

      SELECT 'Gateways - Unused', (SELECT count(distinct gateway) FROM ${db.unused-gateways.table})

      UNION ALL

      SELECT 'Servers', (SELECT count(distinct server) FROM ${db.servers.table})

      UNION ALL

      SELECT 'Probes', (SELECT count(*) FROM ${db.probes.active}) || " ("|| (SELECT count(*) FROM ${db.probes.table}) || ")"

      UNION ALL

      SELECT 'Samplers', (SELECT total(number) FROM ${db.samplers.active})

      UNION ALL

      SELECT 'Dynamic Entities', (SELECT total(number) FROM ${db.ca-samplers.active})

      UNION ALL

      SELECT 'Gateway Samplers', (SELECT total(number) FROM ${db.gw-samplers.active})

      UNION ALL

      SELECT 'Gateway Filters', ' include: ${db.gateways.filter.include}, exclude: ${db.gateways.filter.exclude}'
      ;

  coverage-by-level-and-plugin:
    name: Coverage By Level And Plugin
    group: Monitoring Coverage
    enable-for-xlsx: false
    columns: [ "level # plugin", instances, servers, "servers %", remainingServers, "remainingServers %" ]
    headlines: > #sql
      SELECT 'totalServers', (SELECT count(distinct server) FROM ${db.servers.table});
    query: > #sql
      WITH totals AS (
        SELECT
             (SELECT count(distinct server) FROM ${db.l1plugins-per-server.table}) l1count,
             (SELECT count(distinct server) FROM ${db.l2plugins-per-server.table}) l2count,
             (SELECT count(distinct server) FROM ${db.l3plugins-per-server.table}) l3count,
             (SELECT count(distinct server) FROM ${db.l1covered-servers.table}) l1covered,
             (SELECT count(distinct server) FROM ${db.l2covered-servers.table}) l2covered,
             (SELECT count(distinct server) FROM ${db.l3covered-servers.table}) l3covered,
             (SELECT count(distinct server) FROM ${db.servers.table}) servers
      ), l1 AS (
        SELECT
             plugin,
             (SELECT total(number) FROM ${db.l1plugins-per-server.table} WHERE plugin = l1.plugin) total,
             (SELECT count(distinct server) FROM (SELECT * FROM ${db.l1plugins-per-server.table} WHERE plugin = l1.plugin)) covered
          FROM ${plugins.level1.table} l1
      ), l2 AS (
        SELECT
             plugin,
             (SELECT total(number) FROM ${db.l2plugins-per-server.table} WHERE plugin = l2.plugin) total,
             (SELECT count(*) FROM ${db.l2plugins-per-server.table}) count,
             (SELECT count(*) FROM (SELECT distinct server FROM ${db.l2plugins-per-server.table} WHERE plugin = l2.plugin)) covered
          FROM ${plugins.level2.table} l2
      )
      SELECT 'level1',
             totals.l1count,
             totals.l1covered,
             printf('%d %%', round((totals.l1covered * 100.0 ) / totals.servers)),
             totals.l1count - totals.l1covered,
             printf('%d %%', 100 - round((totals.l1covered * 100.0 ) / totals.servers))
        FROM totals

      UNION ALL

      SELECT 'level1 # ' || plugin,
             l1.total,
             l1.covered,
             printf('%d %%', round((l1.covered * 100.0 ) / totals.servers)),
             totals.l1count - l1.covered,
             printf('%d %%', 100 - round((l1.covered * 100.0 ) / totals.servers))

        FROM totals, l1

      UNION ALL

      SELECT 'level2',
             totals.l2count,
             totals.l2covered,
             printf('%d %%', round((totals.l2covered * 100.0 ) / totals.servers)),
             totals.l2count - totals.l2covered,
             printf('%d %%', 100 - round((totals.l2covered * 100.0 ) / totals.servers))
        FROM totals

      UNION ALL

      SELECT 'level2 # ' || plugin,
             l2.total,
             l2.covered,
             printf('%d %%', round((l2.covered * 100.0 ) / totals.servers)),
             totals.l2count - l2.covered,
             printf('%d %%', 100 - round((l2.covered * 100.0 ) / totals.servers))

        FROM totals, l2

      UNION ALL

      SELECT 'level3',
             totals.l3count,
             totals.l3covered,
             printf('%d %%', round((totals.l3covered * 100.0 ) / totals.servers)),
             totals.servers - totals.l3covered,
             printf('%d %%', 100 - round((totals.l3covered * 100.0 ) / totals.servers))
        FROM totals;
              
  gateway-coverage-by-group:
    name: Gateway Coverage By Group
    group: Monitoring Coverage
    columns: [ group, gateways, complete, "complete %", empty, "empty %", "remaining", "remaining %", "l1complete", "l1complete %", "l1remaining", "l2complete", "l2complete %", "l2remaining", "l3complete", "l3complete %" ]
    query: > #sql
      WITH v AS (
        SELECT grouping,
               count(distinct a.gateway) total,
               count(distinct m.gateway) covered,
               count(distinct e.gateway) empty,
               count(distinct l1.gateway) l1covered,
               count(distinct l2.gateway) l2covered,
               count(distinct l3.gateway) l3covered
          FROM      ${db.gateways.active} a
          LEFT JOIN ${db.covered-gateways.table} m USING (gateway)
          LEFT JOIN ${db.empty-gateways.table} e USING (gateway)
          LEFT JOIN ${db.l1covered-gateways.table} l1 USING (gateway)
          LEFT JOIN ${db.l2covered-gateways.table} l2 USING (gateway)
          LEFT JOIN ${db.l3covered-gateways.table} l3 USING (gateway)
          LEFT JOIN ${db.match-gateways.table} grp USING (gateway)
        GROUP BY grouping
      )
      SELECT COALESCE(grouping, "OTHER"),
             total,
             covered,
             printf('%d %%', round(covered * 100.0 / total)) coveredPercent,
             empty,
             printf('%d %%', round(empty * 100.0 / total)) emptyPercent,
             total - covered - empty remaining,
             printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,
             l1covered - covered,
             printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
             total - l1covered - empty l1remaining,
             l2covered - covered,
             printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
             total - l2covered - empty l2remaining,
             l3covered - covered,
             printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent
        FROM v;

  plugin-groups:
    name: Plugin Groups
    group: Monitoring Coverage
    enable-for-xlsx: false
    columns: [ pluginGroup, servers, instances ]
    query: > #sql
      WITH
        plugins AS (
          SELECT * FROM (
            SELECT DISTINCT gateway, plugin, server FROM ${db.samplers.active}
            UNION ALL
            SELECT DISTINCT gateway, plugin, entity server FROM ${db.ca-samplers.active}
            UNION ALL
            SELECT DISTINCT gateway, plugin, 1 server FROM ${db.gw-samplers.active}
           )
        )
      SELECT grouping,
             COALESCE(count(distinct gateway||":"||server), 0) servers,
             COALESCE(count(server), 0) instances
        FROM plugins
        RIGHT JOIN ${db.match-sampler-plugins.table} USING (plugin)
       GROUP BY grouping
       ORDER BY grouping
      ;

  plugins-per-gateway:
    name: Plugins Per Gateway
    group: Monitoring Coverage
    columns: []
    type: indirect
    # The build-plugin-query is used to construct a dynamic query to
    # build a table of plugins, depending on how many plugins are in the
    # source data
    #
    # Collect *all* plugins ever seen, ignore active and valid filtering
    query: > #sql
      WITH
        plugins AS (
          SELECT * FROM (
            SELECT DISTINCT plugin FROM ${db.samplers.active}
            UNION ALL
            SELECT DISTINCT plugin FROM ${db.ca-samplers.active}
            UNION ALL
            SELECT DISTINCT plugin FROM ${db.gw-samplers.active}
           )
           ORDER BY (SELECT CASE
                      WHEN plugin IN ${plugins.level1.table} THEN 1
                      WHEN plugin IN ${plugins.level2.table} THEN 2
                      WHEN plugin IN ${plugins.level1-optional.table} THEN 3
                      WHEN plugin IN (SELECT DISTINCT plugin FROM ${db.gw-samplers.active}) THEN 5
                      WHEN plugin IN (SELECT DISTINCT plugin FROM ${db.ca-samplers.active}) THEN 6
                      ELSE 4 END), plugin
          
        ),
        lines AS (
          SELECT 'SELECT gateway, (SELECT count(*) FROM ${db.servers.table} q WHERE q.gateway = p.gateway) AS servers' AS part

          UNION ALL

           SELECT ', total(number) FILTER (WHERE plugin = ''' || plugin || ''') AS ''' || plugin || ''''
             FROM plugins

          UNION ALL

          SELECT ' FROM ${db.samplers.active} AS p GROUP BY gateway'
        )
      SELECT group_concat(part, '') FROM lines;

  plugin-summary:
    name: Plugin Summary
    group: Monitoring Coverage
    columns: [ "plugin", "servers", "instances", "tokensAvailable", "tokensUsed", "tokensUsedPct", "previousServers", "previousInstances", "location", "required", "level", "license", "t1" ]
    headlines: > #sql
      SELECT 'totalServers', (SELECT count(distinct server) FROM ${db.servers.table});
    query: | #sql
      WITH
      current(plugin, server, number, individual, location, required, level) AS (
        SELECT plugin, server, number, IIF(individual, 'Instance', 'Server'), 'netprobe',
              CASE
                WHEN plugin IN level1_plugins OR plugin IN level2_plugins THEN 'Required'
                ELSE 'Optional'
              END,
              CASE
                WHEN plugin IN level1_plugins OR plugin IN level1_optional_plugins THEN '1'
                WHEN plugin IN level2_plugins THEN '2'
                WHEN plugin NOT IN level1_plugins
                  AND plugin NOT IN level1_optional_plugins
                  AND plugin NOT IN level2_plugins THEN '3'
                ELSE '0'
              END
          FROM ${db.samplers.active}

        UNION ALL

        SELECT plugin, entity, number, 'Server', 'collectionAgent', 'Optional', 0
          FROM ${db.ca-samplers.active}

        UNION ALL

        SELECT plugin, gateway, number, 'Server', 'gateway', 'Optional', 0
          FROM ${db.gw-samplers.active}
      ),
      previous(plugin, server, number, individual, location, required, level) AS (
        SELECT plugin, server, number, IIF(individual, 'Instance', 'Server'), 'netprobe',
              CASE
                WHEN plugin IN level1_plugins OR plugin IN level2_plugins THEN 'Required'
                ELSE 'Optional'
              END,
              CASE
                WHEN plugin IN level1_plugins OR plugin IN level1_optional_plugins THEN '1'
                WHEN plugin IN level2_plugins THEN '2'
                WHEN plugin NOT IN level1_plugins
                  AND plugin NOT IN level1_optional_plugins
                  AND plugin NOT IN level2_plugins THEN '3'
                ELSE '0'
              END
          FROM ${db.samplers.inactive}

        UNION ALL

        SELECT plugin, entity, number, 'Server', 'collectionAgent', 'Optional', 0
          FROM ${db.ca-samplers.inactive}

        UNION ALL

        SELECT plugin, gateway, number, 'Server', 'gateway', 'Optional', 0
          FROM ${db.gw-samplers.inactive}
      )

      SELECT 
        plugin,
        count(distinct server) servers,
        total(number) instances,
        COALESCE((SELECT COALESCE(sum(total), 'Unlimited') FROM ${db.tokens.table} WHERE token = current.plugin), 0) tokensAvailable,
        COALESCE((SELECT total(used) FROM ${db.tokens.table} WHERE token = current.plugin AND total IS NOT NULL), 0) tokensUsed,
        printf('%d %%', COALESCE((SELECT IIF(sum(total) IS NULL, 0, round(total(used) * 100 / total(total))) FROM ${db.tokens.table} WHERE token = current.plugin AND total IS NOT NULL), 0)) tokensUsedPct,
        (SELECT count(*) FROM previous WHERE plugin = current.plugin) previousServers,
        (SELECT total(number) FROM previous WHERE plugin = current.plugin) previousInstances,
        location,
        required,
        level,
        individual as license,
        1
        FROM current
      GROUP BY plugin

      UNION

      SELECT
        plugin,
        0,
        0,
        COALESCE((SELECT COALESCE(sum(total), 'Unlimited') FROM ${db.tokens.table} WHERE token = previous.plugin), 0) tokensAvailable,
        0,
        0,
        count(distinct server),
        total(number),
        location,
        required,
        level,
        individual as license,
        1
        FROM previous
        WHERE plugin NOT IN (SELECT distinct plugin from current)
      GROUP BY plugin

  coverage-summary:
    name: Coverage Summary
    group: Monitoring Coverage
    columns: [ coverageBy, total, complete, "complete %", empty, "empty %", "remaining", "remaining %", "l1complete", "l1complete %", "l1remaining", "l2complete", "l2complete %", "l2remaining", "l3complete", "l3complete %", "l3remaining" ]
    # The coverage-summary query returns one row per type of summary.
    # This is actively for all Gateways and another for all Probes.
    #
    # Note: The COALESCE() in the percentage lines is necessary in the
    # (rare) case that once all the items are covered we avoid a divide
    # by zero returning NULL.
    query: > #sql
      WITH gw AS (
        SELECT (SELECT count(*) FROM ${db.gateways.active}) total,
               (SELECT count(*) FROM ${db.covered-gateways.table}) covered,
               (SELECT count(*) FROM ${db.empty-gateways.table}) empty,
               (SELECT count(*) FROM ${db.l1covered-gateways.table}) l1covered,
               (SELECT count(*) FROM ${db.l2covered-gateways.table}) l2covered,
               (SELECT count(*) FROM ${db.l3covered-gateways.table}) l3covered
      ), w AS (
        SELECT (SELECT count(*) FROM ${db.probes.active}) total,
               (SELECT count(*) FROM ${db.covered-probes.table}) covered,
               (SELECT count(*) FROM ${db.empty-probes.table}) empty,
               (SELECT count(*) FROM ${db.l1covered-probes.table}) l1covered,
               (SELECT count(*) FROM ${db.l2covered-probes.table}) l2covered,
               (SELECT count(*) FROM ${db.l3covered-probes.table}) l3covered
      ), s AS (
        SELECT (SELECT count(distinct server) FROM ${db.servers.table}) total,
               (SELECT count(distinct server) FROM ${db.covered-servers.table}) covered,
               (SELECT count(distinct server) FROM ${db.empty-servers.table}) empty,
               (SELECT count(distinct server) FROM ${db.l1covered-servers.table}) l1covered,
               (SELECT count(distinct server) FROM ${db.l2covered-servers.table}) l2covered,
               (SELECT count(distinct server) FROM ${db.l3covered-servers.table}) l3covered
      )
      SELECT 'Gateways',
           total,

           covered,
           printf('%d %%', round(covered * 100.0 / total)) coveredPercent,

           empty,
           printf('%d %%', round(empty * 100.0 / total)) emptyPercent,

           total - covered - empty remaining,
           printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,

           l1covered - covered l1covered,
           printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
           total - l1covered - empty l1remaining,

           l2covered - covered l2covered,
           printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
           total - l2covered - empty l2remaining,

           l3covered - covered l3covered,
           printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent,
           total - l3covered - empty l3remaining

        FROM gw

      UNION ALL

      SELECT 'Servers',
           total,
           covered,
           printf('%d %%', round(covered * 100.0 / total)) coveredPercent,
           empty,
           printf('%d %%', round(empty * 100.0 / total)) emptyPercent,
           total - covered - empty remaining,
           printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,
           l1covered - covered l1covered,
           printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
           total - l1covered - empty l1remaining,
           l2covered - covered l2covered,
           printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
           total - l2covered - empty l2remaining,
           l3covered - covered l3covered,
           printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent,
           total - l3covered - empty l3remaining
        FROM s

      UNION ALL

      SELECT 'Probes',
           total,
           covered,
           printf('%d %%', round(covered * 100.0 / total)) coveredPercent,
           empty,
           printf('%d %%', round(empty * 100.0 / total)) emptyPercent,
           total - covered - empty remaining,
           printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,
           l1covered - covered l1covered,
           printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
           total - l1covered - empty l1remaining,
           l2covered - covered l2covered,
           printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
           total - l2covered - empty l2remaining,
           l3covered - covered l3covered,
           printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent,
           total - l3covered - empty l3remaining
        FROM w;

  gateway-coverage:
    name: Gateway Coverage
    group: Monitoring Coverage
    enable-for-xlsx: false
    columns: [ coverage, percent, gateways, remaining, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, description ]
    headlines: > #sql
      SELECT 'totalGateways', (SELECT count(*) FROM ${db.gateways.active})

      UNION

      SELECT 'allGateways', (SELECT count(distinct gateway) FROM ${db.gateways.active})

      UNION

      SELECT 'unusedGateways', (SELECT count(*) FROM ${db.unused-gateways.table})

      ;
    query: > #sql
      WITH gw AS (
        SELECT (SELECT count(*) FROM ${db.gateways.active}) total,
               (SELECT count(*) FROM ${db.covered-gateways.table}) covered,
               (SELECT count(*) FROM ${db.empty-gateways.table}) empty,
               (SELECT count(*) FROM ${db.l1covered-gateways.table}) l1covered,
               (SELECT count(*) FROM ${db.l2covered-gateways.table}) l2covered,
               (SELECT count(*) FROM ${db.l3covered-gateways.table}) l3covered
      ), w AS (
        SELECT total,
               covered,
               empty,
               l1covered,
               l2covered,
               l3covered,
               COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0) l1coveredPercent,
               COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0) l2coveredPercent,
               COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0) l3coveredPercent
          FROM gw LIMIT 1
      )
        SELECT 'Complete Coverage',
             printf('%d %%', round(covered * 100.0 / total)) percent,
             covered,
             '',
             IIF(covered * 100.0 / total > 0, 1, 0),
             IIF(covered * 100.0 / total > 5, 1, 0),
             IIF(covered * 100.0 / total > 10, 1, 0),
             IIF(covered * 100.0 / total > 15, 1, 0),
             IIF(covered * 100.0 / total > 20, 1, 0),
             IIF(covered * 100.0 / total > 25, 1, 0),
             IIF(covered * 100.0 / total > 30, 1, 0),
             IIF(covered * 100.0 / total > 35, 1, 0),
             IIF(covered * 100.0 / total > 40, 1, 0),
             IIF(covered * 100.0 / total > 45, 1, 0),
             IIF(covered * 100.0 / total > 50, 1, 0),
             IIF(covered * 100.0 / total > 55, 1, 0),
             IIF(covered * 100.0 / total > 60, 1, 0),
             IIF(covered * 100.0 / total > 65, 1, 0),
             IIF(covered * 100.0 / total > 70, 1, 0),
             IIF(covered * 100.0 / total > 75, 1, 0),
             IIF(covered * 100.0 / total > 80, 1, 0),
             IIF(covered * 100.0 / total > 85, 1, 0),
             IIF(covered * 100.0 / total > 90, 1, 0),
             IIF(covered * 100.0 / total > 95, 1, 0),
             IIF(covered * 100.0 / total = 100, 1, 0),
             'gateways where all servers have complete coverage'
          FROM w

        UNION ALL

        SELECT 'Incomplete Coverage',
             printf('%d %%', round((total - covered - empty) * 100.0 / total)) percent,
             (total - covered - empty) instances,
             '',
             IIF((total - covered - empty) * 100.0 / total > 0, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 5, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 10, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 15, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 20, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 25, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 30, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 35, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 40, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 45, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 50, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 55, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 60, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 65, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 70, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 75, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 80, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 85, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 90, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 95, 1, 0),
             IIF((total - covered - empty) * 100.0 / total = 100, 1, 0),
             'gateways where servers do not have all levels of coverage'
          FROM w
        
        UNION ALL

      SELECT 'Incomplete Coverage # Level 1 Covered',
             printf('%d %%', round(l1coveredPercent)) percent,
             l1covered - covered gateways,
             total - l1covered - empty remaining,
             IIF(l1coveredPercent > 0, 1, 0),
             IIF(l1coveredPercent > 5, 1, 0),
             IIF(l1coveredPercent > 10, 1, 0),
             IIF(l1coveredPercent > 15, 1, 0),
             IIF(l1coveredPercent > 20, 1, 0),
             IIF(l1coveredPercent > 25, 1, 0),
             IIF(l1coveredPercent > 30, 1, 0),
             IIF(l1coveredPercent > 35, 1, 0),
             IIF(l1coveredPercent > 40, 1, 0),
             IIF(l1coveredPercent > 45, 1, 0),
             IIF(l1coveredPercent > 50, 1, 0),
             IIF(l1coveredPercent > 55, 1, 0),
             IIF(l1coveredPercent > 60, 1, 0),
             IIF(l1coveredPercent > 65, 1, 0),
             IIF(l1coveredPercent > 70, 1, 0),
             IIF(l1coveredPercent > 75, 1, 0),
             IIF(l1coveredPercent > 80, 1, 0),
             IIF(l1coveredPercent > 85, 1, 0),
             IIF(l1coveredPercent > 90, 1, 0),
             IIF(l1coveredPercent > 95, 1, 0),
             IIF(l1coveredPercent = 100, 1, 0),
             'gateways where servers have level 1 coverage, excluding fully covered'
        FROM w

      UNION ALL

      SELECT 'Incomplete Coverage # Level 2 Covered',
             printf('%d %%', round(l2coveredPercent)) percent,
             l2covered - covered gateways,
             total - l2covered - empty remaining,
             IIF(l2coveredPercent > 0, 1, 0),
             IIF(l2coveredPercent > 5, 1, 0),
             IIF(l2coveredPercent > 10, 1, 0),
             IIF(l2coveredPercent > 15, 1, 0),
             IIF(l2coveredPercent > 20, 1, 0),
             IIF(l2coveredPercent > 25, 1, 0),
             IIF(l2coveredPercent > 30, 1, 0),
             IIF(l2coveredPercent > 35, 1, 0),
             IIF(l2coveredPercent > 40, 1, 0),
             IIF(l2coveredPercent > 45, 1, 0),
             IIF(l2coveredPercent > 50, 1, 0),
             IIF(l2coveredPercent > 55, 1, 0),
             IIF(l2coveredPercent > 60, 1, 0),
             IIF(l2coveredPercent > 65, 1, 0),
             IIF(l2coveredPercent > 70, 1, 0),
             IIF(l2coveredPercent > 75, 1, 0),
             IIF(l2coveredPercent > 80, 1, 0),
             IIF(l2coveredPercent > 85, 1, 0),
             IIF(l2coveredPercent > 90, 1, 0),
             IIF(l2coveredPercent > 95, 1, 0),
             IIF(l2coveredPercent = 100, 1, 0),
             'gateways where servers have level 2 coverage, excluding fully covered'
          FROM w

        UNION ALL

        SELECT 'Incomplete Coverage # Level 3 Covered',
             printf('%d %%', round(l3coveredPercent)) percent,
             l3covered - covered instances,
             total - l3covered - empty remaining,
             IIF(l3coveredPercent > 0, 1, 0),
             IIF(l3coveredPercent > 5, 1, 0),
             IIF(l3coveredPercent > 10, 1, 0),
             IIF(l3coveredPercent > 15, 1, 0),
             IIF(l3coveredPercent > 20, 1, 0),
             IIF(l3coveredPercent > 25, 1, 0),
             IIF(l3coveredPercent > 30, 1, 0),
             IIF(l3coveredPercent > 35, 1, 0),
             IIF(l3coveredPercent > 40, 1, 0),
             IIF(l3coveredPercent > 45, 1, 0),
             IIF(l3coveredPercent > 50, 1, 0),
             IIF(l3coveredPercent > 55, 1, 0),
             IIF(l3coveredPercent > 60, 1, 0),
             IIF(l3coveredPercent > 65, 1, 0),
             IIF(l3coveredPercent > 70, 1, 0),
             IIF(l3coveredPercent > 75, 1, 0),
             IIF(l3coveredPercent > 80, 1, 0),
             IIF(l3coveredPercent > 85, 1, 0),
             IIF(l3coveredPercent > 90, 1, 0),
             IIF(l3coveredPercent > 95, 1, 0),
             IIF(l3coveredPercent = 100, 1, 0),
             'gateways where servers have level 2 coverage, excluding fully covered'
          FROM w

        UNION ALL

        SELECT 'No Coverage',
             printf('%d %%', round(empty * 100.0 / total)) percent,
             empty instances,
             '',
             IIF(empty * 100.0 / total > 0, 1, 0),
             IIF(empty * 100.0 / total > 5, 1, 0),
             IIF(empty * 100.0 / total > 10, 1, 0),
             IIF(empty * 100.0 / total > 15, 1, 0),
             IIF(empty * 100.0 / total > 20, 1, 0),
             IIF(empty * 100.0 / total > 25, 1, 0),
             IIF(empty * 100.0 / total > 30, 1, 0),
             IIF(empty * 100.0 / total > 35, 1, 0),
             IIF(empty * 100.0 / total > 40, 1, 0),
             IIF(empty * 100.0 / total > 45, 1, 0),
             IIF(empty * 100.0 / total > 50, 1, 0),
             IIF(empty * 100.0 / total > 55, 1, 0),
             IIF(empty * 100.0 / total > 60, 1, 0),
             IIF(empty * 100.0 / total > 65, 1, 0),
             IIF(empty * 100.0 / total > 70, 1, 0),
             IIF(empty * 100.0 / total > 75, 1, 0),
             IIF(empty * 100.0 / total > 80, 1, 0),
             IIF(empty * 100.0 / total > 85, 1, 0),
             IIF(empty * 100.0 / total > 90, 1, 0),
             IIF(empty * 100.0 / total > 95, 1, 0),
             IIF(empty * 100.0 / total = 100, 1, 0),
             'gateways where no servers have any level of coverage'
          FROM w
        ;

  server-coverage:
    name: Server Coverage
    group: Monitoring Coverage
    enable-for-xlsx: false
    columns: [ coverage, percent, servers, remaining, width300, 100, description ]
    headlines: > #sql
      SELECT 'totalServers', (SELECT count(distinct server) FROM ${db.servers.table});
    query: > #sql
      WITH v AS (
        SELECT (SELECT count(distinct server) FROM ${db.servers.table}) total,
               (SELECT count(distinct server) FROM ${db.covered-servers.table}) covered,
               (SELECT count(distinct server) FROM ${db.empty-servers.table}) empty,
               (SELECT count(distinct server) FROM ${db.l1covered-servers.table}) l1covered,
               (SELECT count(distinct server) FROM ${db.l2covered-servers.table}) l2covered,
               (SELECT count(distinct server) FROM ${db.l3covered-servers.table}) l3covered
      ), w AS (
        SELECT
               total - covered - empty remaining,
               total - l1covered - empty l1remaining,
               total - l2covered - empty l2remaining,
               total - l3covered - empty l3remaining
          FROM v
         LIMIT 1
      )

      SELECT 'Complete Coverage',
             printf('%.0f %%', covered * 100.0 / total) percent,
             covered servers,
             '',
             printf('%d', IIF(covered = 0, 1, covered * 300.0 / total)) width300,
             IIF(covered * 100.0 / total > 99.0, 1, 0),
             'servers with complete coverage of level 1, 2 and 3'
        FROM v

      UNION ALL

      SELECT 'Total Level 1 Covered',
             printf('%.0f %%', l1covered * 100.0 / total) percent,
             l1covered servers,
             '',
             printf('%d', IIF(l1covered = 0, 1, l1covered * 300.0 / total)) width300,
             IIF(l1covered * 100.0 / total > 99.0, 1, 0),
             'servers with level 1 coverage'
        FROM v, w

      UNION ALL

      SELECT 'Total Level 2 Covered',
             printf('%.0f %%', l2covered * 100.0 / total) percent,
             l2covered servers,
             '',
             printf('%d', IIF(l2covered = 0, 1, l2covered * 300.0 / total)) width300,
             IIF(l2covered * 100.0 / total > 99.0, 1, 0),
             'servers with level 2 coverage'

        FROM v, w

      UNION ALL

      SELECT 'Total Level 3 Covered',
             printf('%.0f %%', l3covered * 100.0 / total) percent,
             l3covered servers,
             '',
             printf('%d', IIF(l3covered = 0, 1, l3covered * 300.0 / total)) width300,
             IIF(l3covered * 100.0 / total > 99.0, 1, 0),
             'servers with level 3 coverage'
        FROM v, w

      UNION ALL

      SELECT 'Incomplete Coverage',
             printf('%.0f %%', remaining * 100.0 / total) percent,
             remaining servers,
             '',
             printf('%d', IIF(remaining = 0, 1, remaining * 300.0 / total)) width300,
             IIF(remaining * 100.0 / total > 99.0, 1, 0),
             'servers with incomplete coverage'
        FROM v, w

      UNION ALL

      SELECT 'Incomplete Coverage # Level 1 Covered',
             printf('%.0f %%', (l1covered - covered) * 100.0 / remaining) percent,
             l1covered - covered servers,
             total - l1covered - empty,
             printf('%d', IIF((l1covered - covered) = 0, 1, (l1covered - covered) * 300.0 / remaining)) width300,
             IIF((l1covered - covered) * 100.0 / total > 99.0, 1, 0),
             'servers with incomplete coverage, but with level 1 covered'
        FROM v, w

      UNION ALL

      SELECT 'Incomplete Coverage # Level 2 Covered',
             printf('%.0f %%', (l2covered - covered) * 100.0 / remaining) percent,
             l2covered - covered servers,
             total - l2covered - empty,
             printf('%d', IIF((l2covered - covered) = 0, 1, (l2covered - covered) * 300.0 / remaining)) width300,
             IIF((l2covered - covered) * 100.0 / total > 99.0, 1, 0),
             'servers with incomplete coverage, but with level 2 covered'
        FROM v, w

      UNION ALL

      SELECT 'Incomplete Coverage # Level 3 Covered',
             printf('%.0f %%', (l3covered - covered) * 100.0 / remaining) percent,
             l3covered - covered servers,
             total - l3covered - empty,
             printf('%d', IIF((l3covered - covered) = 0, 1, (l3covered - covered) * 300.0 / remaining)) width300,
             IIF((l3covered - covered) * 100.0 / total > 99.0, 1, 0),
             'servers with incomplete coverage, but with level 3 covered'
        FROM v, w

      UNION ALL

      SELECT 'No Coverage',
             printf('%.0f %%', empty * 100.0 / total) percent,
             empty servers,
             '',
             printf('%d', IIF(empty = 0, 1, empty * 300.0 / total)) width300,
             IIF(empty * 100.0 / total > 99.0, 1, 0),
             'servers with no coverage'
        FROM v;

  missing-coverage:
    name: Missing Coverage
    group: Monitoring Coverage
    columns: [ serverID, server, osVersion, probes, samplers, dynamicEntities, l1missing, l2missing, l3missing, gateways ]
    freeze-to-column: server
    scramble-columns: [ serverID, server, gateways ]
    headlines: > #sql
      WITH t AS (
        SELECT
          (SELECT count(distinct server) FROM ${db.servers.table}) as total
      )

      SELECT 'servers', total FROM t
      UNION
      SELECT 'serversComplete', (SELECT count(distinct server) FROM ${db.covered-servers.table})
      UNION
      SELECT 'serversIncomplete', (SELECT count(distinct server) FROM ${db.uncovered-servers.table})
      UNION
      SELECT 'serversL1Incomplete', total - (SELECT count(distinct server) FROM ${db.l1covered-servers.table}) FROM t
      UNION
      SELECT 'serversL2Incomplete', total - (SELECT count(distinct server) FROM ${db.l2covered-servers.table}) FROM t
      UNION
      SELECT 'serversL3Incomplete', total - (SELECT count(distinct server) FROM ${db.l3covered-servers.table}) FROM t
      UNION
      SELECT 'serversEmpty', (SELECT count(distinct server) FROM ${db.empty-servers.table})

      ;
    query: > #sql
      SELECT server,
             replace(server, ':'||hostID, ''),
             COALESCE(os, ''),
             (SELECT count(*) FROM ${db.probes.active} WHERE server = u.server) probes,
             (SELECT total(number) FROM ${db.samplers.active} WHERE server = u.server) samplers,
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = u.server) as dynamicEntities,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (SELECT plugin FROM ${plugins.level1.table} WHERE plugin NOT IN (SELECT plugin FROM ${db.l1plugins-per-server.table} WHERE server = u.server))), '') l1missing,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (SELECT plugin FROM ${plugins.level2.table} WHERE plugin NOT IN (SELECT plugin FROM ${db.l2plugins-per-server.table} WHERE server = u.server))), '') l2missing,
             (SELECT IIF(server IN (SELECT server FROM ${db.l3covered-servers.table}), '', 'missing')) as l3missing,
             group_concat(gateway, ', ')
        FROM ${db.uncovered-servers.table} u
       GROUP BY server
       ORDER BY samplers ASC, probes DESC, length(l1missing) DESC, length(l2missing) DESC, l3missing DESC;
    conditional-format:
      - test:
          columns: [ samplers, dynamicEntities ]
          condition: "="
          type: number
          value: 0
        set:
          - format: warning
      - test:
          columns: samplers
          condition: ">"
          type: number
          value: 0
        set:
          - format: ok
      - test:
          columns: dynamicEntities
          condition: ">"
          type: number
          value: 0
        set:
          - format: ok
      - test:
          columns: l1missing
          condition: "="
          value: ""
        set:
          - format: ok
      - test:
          columns: l1missing
          condition: "<>"
          value: ""
        set:
          - format: warning
      - test:
          columns: l2missing
          condition: "="
          value: ""
        set:
          - format: ok
      - test:
          columns: l2missing
          condition: "<>"
          value: ""
        set:
          - format: warning
      - test:
          columns: l3missing
          condition: "<>"
          value: "missing"
        set:
          - format: ok
      - test:
          columns: l3missing
          condition: "="
          value: "missing"
        set:
          - format: warning

  coverage-per-gateway-summary:
    name: ${value} Overview
    group: Gateways
    enable-for-dataview: false
    enable-for-xlsx: false
    columns: [ serverID, server, osVersion, probes, probeVersion, samplers, dynamicEntities, l1missing, l2missing, l3missing, otherGateways, plugins ]
    freeze-to-column: server
    scramble-columns: [ serverID, server ]
    type: split
    split-column: gateway
    split-values-query: SELECT ${reports.coverage-per-gateway-summary.split-column} FROM ${db.gateways.active}
    headlines: > #sql
      WITH t AS (
        SELECT
          (SELECT count(distinct server) FROM ${db.servers.table} WHERE ${split-column} = '${value}') as total
      )

      SELECT 'gatewayHost', (SELECT COALESCE(gatewayHost, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'gatewayPort', (SELECT COALESCE(gatewayPort, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'gatewayVersion', (SELECT COALESCE(version, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'servers', total FROM t
      UNION
      SELECT 'relatedProbes', (SELECT count(*) FROM ${db.probes.active} WHERE server IN (SELECT server FROM ${db.servers.table} WHERE ${split-column} = '${value}')) - total FROM t
      UNION
      SELECT 'serversEmpty', (SELECT count(distinct server) FROM ${db.empty-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversIncomplete', (SELECT count(distinct server) FROM ${db.uncovered-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversComplete', (SELECT count(distinct server) FROM ${db.covered-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversL1Incomplete', total - (SELECT count(distinct server) FROM ${db.l1covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'serversL2Incomplete', total - (SELECT count(distinct server) FROM ${db.l2covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'serversL3Incomplete', total - (SELECT count(distinct server) FROM ${db.l3covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'dynamicEntities', (SELECT total(number) FROM ${db.ca-samplers.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'dynamicEntitiesUnknownServer', (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server IS NULL AND ${split-column} = '${value}')
      ;
    query: > #sql
      SELECT server,
             replace(server, ':'||hostID, ''),
             COALESCE(CASE (SELECT count(distinct os) FROM ${db.probes.active} WHERE server = u.server)
                           WHEN 0 THEN ''
                           WHEN 1 THEN (SELECT os FROM ${db.probes.active} WHERE server = u.server LIMIT 1)
                           ELSE 'multiple'
                           END, '') osVersion,
             (SELECT count(*) FROM ${db.probes.active} WHERE server = u.server) probes,
             COALESCE(CASE (SELECT count(distinct version) FROM ${db.probes.active} WHERE server = u.server)
                           WHEN 0 THEN ''
                           WHEN 1 THEN (SELECT version FROM ${db.probes.active} WHERE server = u.server LIMIT 1)
                           ELSE 'multiple'
                           END, '') probeVersions,
             (SELECT total(number) FROM ${db.samplers.active} WHERE server = u.server) samplers,
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = u.server AND ${split-column} = '${value}') as dynamicEntities,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (SELECT plugin FROM ${plugins.level1.table} WHERE plugin NOT IN (SELECT plugin FROM ${db.l1plugins-per-server.table} WHERE server = u.server))), '') l1missing,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (SELECT plugin FROM ${plugins.level2.table} WHERE plugin NOT IN (SELECT plugin FROM ${db.l2plugins-per-server.table} WHERE server = u.server))), '') l2missing,
             (SELECT IIF(server IN (SELECT server FROM ${db.l3covered-servers.table}), '', 'missing')) as l3missing,
             COALESCE((SELECT group_concat(gateway, ', ') FROM ${db.servers.table} WHERE server = u.server AND gateway <> u.gateway), '') otherGateways,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (
                          SELECT distinct plugin FROM ${db.samplers.active} WHERE server = u.server
                          UNION     
                          SELECT distinct plugin FROM ${db.ca-samplers.active} WHERE server = u.server
                          ORDER BY 1
                     )), '') plugins
        FROM ${db.servers.table} u
       WHERE ${split-column} = '${value}'
       GROUP BY server
       
      ORDER BY 1
      ;
    conditional-format:
      - test:
          columns: [ samplers, dynamicEntities ]
          condition: "="
          type: number
          value: 0
        set:
          - format: warning
      - test:
          columns: samplers
          condition: ">"
          type: number
          value: 0
        set:
          - format: ok
      - test:
          columns: dynamicEntities
          condition: ">"
          type: number
          value: 0
        set:
          - format: ok
      - test:
          columns: l1missing
          condition: "="
          value: ""
        set:
          - format: ok
      - test:
          columns: l1missing
          condition: "<>"
          value: ""
        set:
          - format: warning
      - test:
          columns: l2missing
          condition: "="
          value: ""
        set:
          - format: ok
      - test:
          columns: l2missing
          condition: "<>"
          value: ""
        set:
          - format: warning
      - test:
          columns: l3missing
          condition: "<>"
          value: "missing"
        set:
          - format: ok
      - test:
          columns: l3missing
          condition: "="
          value: "missing"
        set:
          - format: warning

  coverage-per-gateway-detail:
    name: ${value} Detail
    group: Gateways
    enable-for-dataview: false
    enable-for-xlsx: false
    columns: [ serverID, server, osVersion, probes, probeName, probePort, probeVersion, otherGateways, samplers, dynamicEntities, l1missing, l2missing, l3missing, plugins ]
    freeze-to-column: probePort
    scramble-columns: [ serverID, server, probeName ]
    type: split
    split-column: gateway
    split-values-query: SELECT ${reports.coverage-per-gateway-detail.split-column} FROM ${db.gateways.active}
    headlines: > #sql
      WITH t AS (
        SELECT
          (SELECT count(distinct server) FROM ${db.servers.table} WHERE ${split-column} = '${value}') as total
      )

      SELECT 'gatewayHost', (SELECT COALESCE(gatewayHost, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'gatewayPort', (SELECT COALESCE(gatewayPort, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'gatewayVersion', (SELECT COALESCE(version, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'servers', total FROM t
      UNION
      SELECT 'relatedProbes', (SELECT count(*) FROM ${db.probes.active} WHERE server IN (SELECT server FROM ${db.servers.table} WHERE ${split-column} = '${value}')) - total FROM t
      UNION
      SELECT 'serversEmpty', (SELECT count(distinct server) FROM ${db.empty-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversIncomplete', (SELECT count(distinct server) FROM ${db.uncovered-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversComplete', (SELECT count(distinct server) FROM ${db.covered-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversL1Incomplete', total - (SELECT count(distinct server) FROM ${db.l1covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'serversL2Incomplete', total - (SELECT count(distinct server) FROM ${db.l2covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'serversL3Incomplete', total - (SELECT count(distinct server) FROM ${db.l3covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'dynamicEntities', (SELECT total(number) FROM ${db.ca-samplers.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'dynamicEntitiesUnknownServer', (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server IS NULL AND ${split-column} = '${value}')

      ;
    query: > #sql
      SELECT server serverID,
             replace(server, ':'||hostID, '') server,
            COALESCE(CASE (SELECT count(distinct os) FROM ${db.probes.active} WHERE server = u.server)
                           WHEN 0 THEN ''
                           WHEN 1 THEN (SELECT os FROM ${db.probes.active} WHERE server = u.server LIMIT 1)
                           ELSE 'multiple'
                           END, '') osVersion,
             (SELECT count(*) FROM ${db.probes.active} WHERE server = u.server) probes,
             '' probeName,
             '' probePort,
             COALESCE(CASE (SELECT count(distinct version) FROM ${db.probes.active} WHERE server = u.server)
                           WHEN 0 THEN ''
                           WHEN 1 THEN (SELECT version FROM ${db.probes.active} WHERE server = u.server LIMIT 1)
                           ELSE 'multiple'
                           END, '') probeVersions,
             '' otherGateways,
             (SELECT total(number) FROM ${db.samplers.active} WHERE server = u.server) samplers,
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = u.server) as dynamicEntities,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (SELECT plugin FROM ${plugins.level1.table} WHERE plugin NOT IN (SELECT plugin FROM ${db.l1plugins-per-server.table} WHERE server = u.server))), '') l1missing,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (SELECT plugin FROM ${plugins.level2.table} WHERE plugin NOT IN (SELECT plugin FROM ${db.l2plugins-per-server.table} WHERE server = u.server))), '') l2missing,
             (SELECT IIF(server IN (SELECT server FROM ${db.l3covered-servers.table} WHERE ${split-column} = '${value}'), '', 'missing')) as l3missing,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (
                          SELECT distinct plugin FROM ${db.samplers.active} WHERE server = u.server
                          UNION     
                          SELECT distinct plugin FROM ${db.ca-samplers.active} WHERE server = u.server
                          ORDER BY 1
                     )), '') plugins
        FROM ${db.servers.table} u
       WHERE ${split-column} = '${value}'
       GROUP BY server
       
      UNION

      SELECT server || ' # ' || probePort serverID,
              '' server,
              COALESCE(os, '') osVersion,
              '' probes,
              probeName,
              probePort,
              COALESCE(version, '') probeVersion,
              IIF(p.gateway <> '${value}', p.gateway, '') otherGateways,
              (SELECT total(number) FROM ${db.samplers.active} WHERE gateway = p.gateway AND probeName = p.probeName AND probePort = p.probePort) samplers,
              (SELECT total(number) FROM ${db.ca-samplers.active} WHERE gateway = p.gateway AND probeName = p.probeName AND probePort = p.probePort) as dynamicEntities,
              '' l1missing,
              '' l2missing,
              '' l3missing,
              COALESCE((SELECT group_concat(plugin, ', ') FROM (
                          SELECT distinct plugin FROM ${db.samplers.active} WHERE gateway = p.gateway AND probeName = p.probeName AND probePort = p.probePort
                          UNION     
                          SELECT distinct plugin FROM ${db.ca-samplers.active} WHERE gateway = p.gateway AND probeName = p.probeName AND probePort = p.probePort
                          ORDER BY 1
                     )), '') plugins
        FROM ${db.probes.active} p
        WHERE server IN (SELECT server FROM ${db.servers.table} WHERE ${split-column} = '${value}')

      ORDER BY 1
      ;
    conditional-format:
      - test:
          columns: [ samplers, dynamicEntities ]
          condition: "="
          type: number
          value: 0
        set:
          - format: warning
      - test:
          columns: samplers
          condition: ">"
          type: number
          value: 0
        set:
          - format: ok
      - test:
          columns: dynamicEntities
          condition: ">"
          type: number
          value: 0
        set:
          - format: ok
      - test:
          columns: l1missing
          condition: "="
          value: ""
        set:
          - not-rows: "*#*"
            format: ok
      - test:
          columns: l1missing
          condition: "<>"
          value: ""
        set:
          - not-rows: "*#*"
            format: warning
      - test:
          columns: l2missing
          condition: "="
          value: ""
        set:
          - not-rows: "*#*"
            format: ok
      - test:
          columns: l2missing
          condition: "<>"
          value: ""
        set:
          - not-rows: "*#*"
            format: warning
      - test:
          columns: l3missing
          condition: "<>"
          value: "missing"
        set:
          - not-rows: "*#*"
            format: ok
      - test:
          columns: l3missing
          condition: "="
          value: "missing"
        set:
          - not-rows: "*#*"
            format: warning

  plugin-coverage:
    name: Plugin Coverage
    group: Monitoring Coverage
    enable-for-xlsx: false
    columns: [ coverage, percent, servers, width300, 100, remaining, description ]
    headlines: > #sql
      SELECT 'totalServers', (SELECT count(distinct server) FROM ${db.servers.table});
    query: > #sql
      WITH v AS (
        SELECT (SELECT count(distinct server) FROM ${db.servers.table}) total,
               (SELECT count(distinct server) FROM ${db.covered-servers.table}) covered,
               (SELECT count(distinct server) FROM ${db.empty-servers.table}) empty,
               (SELECT count(distinct server) FROM ${db.l1covered-servers.table}) l1covered,
               COALESCE((SELECT count(distinct server) FROM ${db.l1covered-servers.table}) * 100.0 / (SELECT count(distinct server) FROM ${db.servers.table}), 0) l1coveredPercent,
               (SELECT count(distinct server) FROM ${db.l2covered-servers.table}) l2covered,
               COALESCE((SELECT count(distinct server) FROM ${db.l2covered-servers.table}) * 100.0 / (SELECT count(distinct server) FROM ${db.servers.table}), 0) l2coveredPercent,
               (SELECT count(distinct server) FROM ${db.l3covered-servers.table}) l3covered,
               COALESCE((SELECT count(distinct server) FROM ${db.l3covered-servers.table}) * 100.0 / (SELECT count(distinct server) FROM ${db.servers.table}), 0) l3coveredPercent
      )
      
      SELECT 'Complete Coverage',
             printf('%d %%', round(covered * 100.0 / total)) percent,
             covered servers,
             printf('%d', IIF(covered = 0, 1, covered * 300.0 / total)) width300,
             IIF(covered * 100.0 / total = 100, 1, 0),
             '',
             'servers with complete coverage'
        FROM v

      UNION ALL

      SELECT 'Level 1 Coverage',
             printf('%d %%', round(l1coveredPercent)) percent,
             l1covered servers,
             printf('%d', IIF(l1coveredPercent = 0, 1, 3 * l1coveredPercent)) width300,
             IIF(l1coveredPercent = 100, 1, 0),
             total - l1covered remaining,
             'servers with level 1 coverage'
        FROM v

      UNION ALL

      SELECT 'Level 2 Coverage',
             printf('%d %%', round(l2coveredPercent)) percent,
             l2covered servers,
             printf('%d', IIF(l2coveredPercent = 0, 1, 3 * l2coveredPercent)) width300,
             IIF(l2coveredPercent = 100, 1, 0),
             total - l2covered remaining,
             'servers with level 2 coverage'

        FROM v

      UNION ALL

      SELECT 'Level 3 Coverage',
             printf('%d %%', round(l3coveredPercent)) percent,
             l3covered servers,
             printf('%d', IIF(l3coveredPercent = 0, 1, 3 * l3coveredPercent)) width300,
             IIF(l3coveredPercent = 100, 1, 0),
             total - l3covered remaining,
             'servers with level 3 coverage'
        FROM v

      UNION ALL

      SELECT 'Incomplete Coverage',
             printf('%d %%', round((total - covered - empty) * 100.0 / total)) percent,
             (total - covered - empty) servers,
              printf('%d', iif((total - covered - empty) = 0, 1, (total - covered - empty) * 300.0 / total)) width300,
             IIF((total - covered - empty) * 100.0 / total = 100, 1, 0),
             '',
             'servers with some level 1, 2 or 3 coverage'
        FROM v

      UNION ALL

      SELECT 'No Coverage',
             printf('%d %%', round(empty * 100.0 / total)) percent,
             empty servers,
             printf('%d', IIF(empty = 0, 1, empty * 300.0 / total)) width300,
             IIF(empty * 100.0 / total = 100, 1, 0),
             '',
             'servers with no level of coverage'
        FROM v;

  licence-sources:
    name: Licence Sources
    group: GDNA Information
    columns: [ licenceSource, status, firstSeen, lastSeen, sourceType, path, valid, extendedFormat, gateways, probes, samplers, dynamicEntities, serverTokens, serverTokensUsed, serverTokensFree, licenceName, licenceExpiry, licenceMode, licenceHostname, licenceHostID ]
    headlines: > #sql
      SELECT 'latestUpdate', max(lastSeen)
        FROM ${db.sources.table}

      UNION ALL

      SELECT 'latestLicenceSource', source
        FROM ${db.sources.table}
       WHERE lastSeen = (SELECT max(lastSeen) FROM ${db.sources.table})

      UNION ALL

      SELECT 'totalSources', count(*)
        FROM ${db.sources.table}

      UNION ALL

      SELECT 'erroredSources', count(*)
        FROM ${db.sources.table}
       WHERE status LIKE 'ERROR:%'
       
      UNION ALL

      SELECT 'staleSources', count(*)
        FROM ${db.sources.table}
       WHERE valid = 0
      
      UNION ALL

      SELECT 'totalServerTokens', COALESCE(total(total), 0)
        FROM ${db.tokens.table}
       WHERE token = 'servers'
      ;

    query: > #sql
      WITH os(os, source, lastSeen) AS (SELECT os, source, lastSeen FROM ${db.probes.table})
      SELECT ${db.sources.columns},
             (SELECT IIF((SELECT count(os) FROM os WHERE source = src.source AND lastSeen = src.lastSeen), 1, 0)) as extendedFormat,
             (SELECT count(*) FROM ${db.gateways.table} WHERE source = src.source AND lastSeen = src.lastSeen) AS gateways,
             (SELECT count(*) FROM ${db.probes.table}   WHERE source = src.source AND lastSeen = src.lastSeen) AS probes,
             (SELECT total(number) FROM ${db.samplers.table} WHERE source = src.source AND lastSeen = src.lastSeen) AS samplers,
             (SELECT total(number) FROM ${db.ca-samplers.table} WHERE source = src.source AND lastSeen = src.lastSeen) AS dynamicEntities,
             COALESCE((SELECT COALESCE(total, 'Unlimited') FROM ${db.tokens.table} WHERE token = 'servers' AND source = src.source AND lastSeen = src.lastSeen), 0),
             COALESCE((SELECT COALESCE(used, 0) FROM ${db.tokens.table} WHERE token = 'servers' AND source = src.source AND lastSeen = src.lastSeen), 0),
             COALESCE((SELECT COALESCE(free, 'Unlimited') FROM ${db.tokens.table} WHERE token = 'servers' AND source = src.source AND lastSeen = src.lastSeen), 0),
             COALESCE(licenceName, ''),
             COALESCE(licenceExpiry, ''),
             COALESCE(licenceMode, ''),
             COALESCE(hostname, ''),
             COALESCE(hostID, '')
        FROM ${db.sources.table} src
        LEFT JOIN ${db.sources-licence.table} USING (source)
       WHERE valid = 1

      UNION ALL

      SELECT ${db.sources.columns},
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             COALESCE(licenceName, ''),
             COALESCE(licenceExpiry, ''),
             COALESCE(licenceMode, ''),
             COALESCE(hostname, ''),
             COALESCE(hostID, '')
        FROM ${db.sources.table}
        LEFT JOIN ${db.sources-licence.table} USING (source)
       WHERE valid = 0

       ORDER BY source;

  unused-gateways:
    name: Unused Gateways
    group: Monitoring Coverage
    columns: [ gateway, lastSeen, licenceSources ]
    scramble-columns: [ gateway ]
    query: > #sql
      SELECT gateway, max(lastSeen), group_concat(source, ',')
        FROM ${db.unused-gateways.table}
       GROUP BY gateway

  gateway-summary:
    name: Gateways
    group: Monitored Estate
    columns: [ gateway, gatewayHost, gatewayPort, gatewayVersion, servers, probes, samplers, dynamicEntities, dynamicEntitiesUnknownServer, serversComplete, serversIncomplete, serversEmpty, licenseSource ]
    scramble-columns: [ gatewayHost ]
    query: | #sql
      SELECT gateway,
             COALESCE(gatewayHost, ''),
             COALESCE(gatewayPort, ''),
             COALESCE(version, ''),
             (SELECT count(distinct server) FROM ${db.servers.table} WHERE gateway = g.gateway),
             (SELECT count(*) FROM ${db.probes.active} WHERE gateway = g.gateway),
             (SELECT total(number) FROM ${db.samplers.active} WHERE gateway = g.gateway),
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE gateway = g.gateway),
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server IS NULL AND gateway = g.gateway),
             (SELECT count(distinct server) FROM ${db.covered-servers.table} WHERE gateway = g.gateway),
             (SELECT count(distinct server) FROM ${db.uncovered-servers.table} WHERE gateway = g.gateway),
             (SELECT count(distinct server) FROM ${db.empty-servers.table} WHERE gateway = g.gateway) AS empty,
             source
        FROM ${db.gateways.active} g
      ;

  server-summary:
    name: Servers
    group: Monitored Estate
    enable-for-dataview: false
    columns: [ serverID, server, osVersion, probes, samplers, dynamicEntities, l1missing, l2missing, l3missing, gateways, plugins ]
    scramble-columns: [ serverID, server ]
    headlines: > #sql
      WITH t AS (
        SELECT
          (SELECT count(distinct server) FROM ${db.servers.table}) as total
      )

      SELECT 'servers', total FROM t
      UNION
      SELECT 'serversComplete', (SELECT count(distinct server) FROM ${db.covered-servers.table})
      UNION
      SELECT 'serversIncomplete', (SELECT count(distinct server) FROM ${db.uncovered-servers.table})
      UNION
      SELECT 'serversL1Incomplete', total - (SELECT count(distinct server) FROM ${db.l1covered-servers.table}) FROM t
      UNION
      SELECT 'serversL2Incomplete', total - (SELECT count(distinct server) FROM ${db.l2covered-servers.table}) FROM t
      UNION
      SELECT 'serversL3Incomplete', total - (SELECT count(distinct server) FROM ${db.l3covered-servers.table}) FROM t
      UNION
      SELECT 'serversEmpty', (SELECT count(distinct server) FROM ${db.empty-servers.table})

      ;
    query: > #sql
      SELECT server AS serverID,
             replace(server, ':'||hostID, '') server,
             COALESCE(os, ''),
             (SELECT count(*) FROM ${db.probes.active} WHERE server = s.server),
             (SELECT total(number) FROM ${db.samplers.active} WHERE server = s.server),
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = s.server),
             COALESCE((SELECT group_concat(plugin, ', ') FROM (SELECT plugin FROM ${plugins.level1.table} WHERE plugin NOT IN (SELECT plugin FROM ${db.l1plugins-per-server.table} WHERE server = s.server))), '') l1missing,
             COALESCE((SELECT group_concat(plugin, ', ') FROM (SELECT plugin FROM ${plugins.level2.table} WHERE plugin NOT IN (SELECT plugin FROM ${db.l2plugins-per-server.table} WHERE server = s.server))), '') l2missing,
             (SELECT IIF(server IN (SELECT server FROM ${db.l3covered-servers.table}), '', 'missing')) as l3missing,
             group_concat(gateway, ','),
             COALESCE((SELECT group_concat(plugin, ', ') FROM (
                          SELECT distinct plugin FROM ${db.samplers.active} WHERE server = s.server
                          UNION     
                          SELECT distinct plugin FROM ${db.ca-samplers.active} WHERE server = s.server
                          ORDER BY 1
                     )), '') plugins
        FROM ${db.servers.table} s
       GROUP BY server
       -- order by the number of sampler plus dynamic entities, so the least monitored appear first
       ORDER BY (SELECT total(number) FROM ${db.samplers.active} WHERE server = s.server) + (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = s.server)
      ;
    conditional-format:
      - test:
          columns: [ samplers, dynamicEntities ]
          condition: "="
          type: number
          value: 0
        set:
          - format: warning
      - test:
          columns: samplers
          condition: ">"
          type: number
          value: 0
        set:
          - format: ok
      - test:
          columns: dynamicEntities
          condition: ">"
          type: number
          value: 0
        set:
          - format: ok
      - test:
          columns: l1missing
          condition: "="
          value: ""
        set:
          - format: ok
      - test:
          columns: l1missing
          condition: "<>"
          value: ""
        set:
          - format: warning
      - test:
          columns: l2missing
          condition: "="
          value: ""
        set:
          - format: ok
      - test:
          columns: l2missing
          condition: "<>"
          value: ""
        set:
          - format: warning
      - test:
          columns: l3missing
          condition: "<>"
          value: "missing"
        set:
          - format: ok
      - test:
          columns: l3missing
          condition: "="
          value: "missing"
        set:
          - format: warning

  os-versions:
    name: Operating System Versions
    group: GDNA Information
    columns: [ osVersion, count ]
    query: | #sql
      SELECT os, count(*)
        FROM ${db.servers.table}
       WHERE os IS NOT NULL
       GROUP BY os

      UNION

      SELECT 'Unknown', count(*)
        FROM ${db.servers.table}
       WHERE os IS NULL
      ;

  probe-versions:
    name: Probe Versions
    group: GDNA Information
    columns: [ probeVersion, count ]
    query: | #sql
      SELECT version, count(*)
        FROM ${db.probes.active}
       WHERE version IS NOT NULL
       GROUP BY version

      UNION

      SELECT 'Unknown', count(*)
        FROM ${db.probes.active}
       WHERE version IS NULL
      ;

  gateway-versions:
    name: Gateway Versions
    group: GDNA Information
    columns: [ gatewayVersion, count ]
    query: | #sql
      SELECT version, count(*)
        FROM ${db.gateways.active}
       WHERE version IS NOT NULL
       GROUP BY version

      UNION

      SELECT 'Unknown', count(*)
        FROM ${db.gateways.active}
       WHERE version IS NULL
      ;