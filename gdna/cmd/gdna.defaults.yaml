# This is the default configuration included in the `gdna` program.

# Please see the main example `gdna.yaml` file for explanations of the
# settings.

# Some additional comments exist in this file for sections that are not
# normally changed by users; See below for more.

gdna:
  site-name: ITRS
  licd-sources: 
    - "http://localhost:7041"
    - "https://localhost:7041"
  licd-reports:
    # - "~/geneos/licd/licds/*/reporting/summary*"
  schedule: "*/15 * * * *"
  email-schedule: ""
  stale-after: 12h
  licd-timeout: 10s
  licd-chain: ""
  licd-skip-verify: false
  log:
    filename: ./gdna.log
    max-size: 10
    max-backups: 50
    max-age: 14
    compress: true
    rotate-on-start: true

geneos:
  netprobe:
    hostname: localhost
    port: 8101
    secure: true
    skip-verify: true
  entity: GDNA
  sampler: GDNA
  max-rows: 500
  scramble: false
  dataview-create-delay: 0

xlsx:
  password: ""
  scramble: true
  summary-report: gdna-summary
  formats:
    int: 1
    percent: 9
    datetime: "yyyy-mm-ddThh:MM:ss"
    min-width: 10.0
    max-width: 30.0
  conditional-formats:
    ok: 43d815
    warning: fcd600
    critical: ee1212
    undefined: ffffff
  headlines: 2

email:
  smtp-server: smtp.example.com
  port: 0
  tls: default
  tls-insecure: false
  timeout: 10s
  username: ""
  password: ""
  key-file: ""
  credentials-file: ""

  subject: ITRS GDNA EMail Report
  from: sender@example.com
  to: recipient@example.com
  cc: ""
  bcc: ""
  body-reports: gdna-summary
  contents: [ xlsx ]
  xlsx-name: itrs-gdna-report.xlsx
  html-name: itrs-gdna-report.html
  scramble: true
  html-preamble: |
    <html>
    <head>
      <style>
      table.gdna-headlines,
      table.gdna-headlines th,
      table.gdna-headlines td,
      table.gdna-dataview,
      table.gdna-dataview th,
      table.gdna-dataview td {
        table-layout: fixed;
        font-family: Lucida Console, monospace;
        border: 1px solid black;
        border-collapse: collapse;
        padding: 5px;
        text-align: left;
        vertical-align: top;
      }
      td.gdna-dataview {
        word-wrap: break-word;
      }

      </style>
    </head>
    <body>
      <h1>ITRS Geneos GDNA Default Template</h1>

      <p>This content has been generated by the default template built
      into the gdna program from the ITRS <a
      href="https://github.com/ITRS-Group/cordial">cordial</a> tools.
      It is normally only seen when testing. If you did not expect to
      receive this please contact the sender and let them know.</p>

      <h2>Report Summary</h2>

      <p></p>
  html-postscript: |
    </body>
    </html>

# `filters-file` contains the on-disk list of filters: includes,
# excludes and groups.
#
# It is intended to be created, read and written by the gdna program
# directly and should not be hand edited. It is used as a persistent
# store for the data to be loaded into the SQLite temporary tables
# before each reporting run, so as to not require database access
# outside the main program thread.
#
# The file can be YAML or JSON and the contents must be in the form:
#
#     exclude:
#       CATEGORY:
#         - name: NAME
#           user: Who
#           timestamp: ISO8601
#           comment: Why
#           source: From
#     include:
#       ...
#     groups:
#       ...
#
# or
#
#     {
#        "exclude": {
#           "CATEGORY": [
#             {
#               "comment": "test",
#               "name": "PROD_02",
#               "source": "cli",
#               "timestamp": "2024-09-20T17:05:42+01:00",
#               "user": "Peter"
#             }
#           ]
#        }
#     }
#
# where `CATEGORY` must match on of the types in the `exclude` section
# below. The files are read and written using the cordial config.Load(),
# config.Save() functions.
#
# The default is `gdna-filters.yaml` in the normal config directories
#
# include and exclude filter categories must be made up of tables with exactly one column
filters:
  file: ""
  exclude:
    gateway:
      table: gateway_exclude
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.gateway.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.gateway.table} (
          gateway       TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.exclude.gateway.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;
    server:
      table: server_exclude
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.server.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.server.table} (
          server        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.exclude.server.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;
    hostid:
      table: hostid_exclude
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.hostid.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.hostid.table} (
          hostid        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.exclude.hostid.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;
    source:
      table: source_exclude
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.source.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.source.table} (
          source        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.exclude.source.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;
    plugin:
      table: plugin_exclude
      create: > #sql
        DROP TABLE IF EXISTS ${filters.exclude.plugin.table};
        CREATE ${db.temporary-table} TABLE ${filters.exclude.plugin.table} (
          plugin        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.exclude.plugin.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;

  include:
    gateway:
      table: gateway_include
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.gateway.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.gateway.table} (
          gateway       TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.include.gateway.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;
    server:
      table: server_include
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.server.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.server.table} (
          server        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.include.server.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;
    hostid:
      table: hostid_include
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.hostid.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.hostid.table} (
          hostid        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.include.hostid.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;
    source:
      table: source_include
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.source.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.source.table} (
          source        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.include.source.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;
    plugin:
      table: plugin_include
      default: "*"
      create: | #sql
        DROP TABLE IF EXISTS ${filters.include.plugin.table};
        CREATE ${db.temporary-table} TABLE ${filters.include.plugin.table} (
          plugin        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.include.plugin.table}
          VALUES (@name, @user, @origin, @comment, @timestamp)
        ;

  group:
    gateway:
      table: gateway_groups
      create: | #sql
        DROP TABLE IF EXISTS ${filters.group.gateway.table};
        CREATE ${db.temporary-table} TABLE ${filters.group.gateway.table} (
          grouping      TEXT NOT NULL,
          gateway       TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.group.gateway.table}
          VALUES (@grouping, @pattern, @user, @origin, @comment, @timestamp)
        ;
    server:
      table: server_groups
      create: | #sql
        DROP TABLE IF EXISTS ${filters.group.server.table};
        CREATE ${db.temporary-table} TABLE ${filters.group.server.table} (
          grouping      TEXT NOT NULL,
          server        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.group.server.table}
          VALUES (@grouping, @pattern, @user, @origin, @comment, @timestamp)
        ;
    source:
      table: source_groups
      create: | #sql
        DROP TABLE IF EXISTS ${filters.group.source.table};
        CREATE ${db.temporary-table} TABLE ${filters.group.source.table} (
          grouping      TEXT NOT NULL,
          source        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.group.source.table}
          VALUES (@grouping, @pattern, @user, @origin, @comment, @timestamp)
        ;
    plugin:
      table: plugin_groups
      default: |
        e4jms-plugins,e4jms-*
        ibmi-plugins,ibmi-*
        mq-plugins,mq-*
        wts-plugins,wts-*
        x-plugins,x-*
        sybase-plugins,sybase*
        prometheus-plugins,*prometheus*
        tib-plugins,tib*
        jmx-plugins,jmx*
        cloud-plugins,aws-plugin
        cloud-plugins,azure-plugin
        cloud-plugins,gcp-plugin
      create: | #sql
        DROP TABLE IF EXISTS ${filters.group.plugin.table};
        CREATE ${db.temporary-table} TABLE ${filters.group.plugin.table} (
          grouping      TEXT NOT NULL,
          plugin        TEXT NOT NULL,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.group.plugin.table}
          VALUES (@grouping, @pattern, @user, @origin, @comment, @timestamp)
        ;

  allocations:
    gateway:
      table: gateway_group_allocations
      default: ""
      create: | #sql
        DROP TABLE IF EXISTS ${filters.allocations.gateway.table};
        CREATE ${db.temporary-table} TABLE ${filters.allocations.gateway.table} (
          grouping      TEXT NOT NULL,
          token         TEXT NOT NULL,
          allocation    INT,
          user          TEXT,
          origin        TEXT,
          comment       TEXT,
          timestamp     TIMESTAMP DEFAULT 'now'
        );
      insert: | #sql
        INSERT INTO ${filters.allocations.gateway.table}
          VALUES (@grouping, @token, @allocation, @user, @origin, @comment, @timestamp)
        ;

db:
  temporary-table: TEMPORARY
  file: gdna.sqlite
  dsn: "file:${db.file}?cache=shared"
  on-open: > #sql
    PRAGMA journal_mode='wal';
    PRAGMA synchronous='normal';
    PRAGMA temp_store='memory';
    PRAGMA mmap_size=100000000;
    ;

  # `main-tables` is a list of the tables to create and populate in the
  # database. These tables store data loaded from sources and some
  # derived information that does not need to be recreated before each
  # report run.
  #
  # The tables are created in the order given.
  #
  # Each one may also define an `active` and/or an `inactive` table,
  # which are both created later, but before `report-tables` below.
  #
  # Filters, when defined, act on these active/inactive temporary tables
  # during their build time.
  main-tables:
    - sources
    - sources-licence
    - reporting-updates
    - probes
    - samplers
    - ca-samplers
    - gw-samplers
    - gw-components
    - gateways
    - tokens

  # `report-tables` is a list of (temporary) tables to create for
  # reporting from the primary source data. These tables are fully
  # recreated before each report run and also if the `--post-process`
  # flag is give to `fetch` (the latter only useful for debugging, if
  # the report tables are stored on disk). If `db.temporary-table` is
  # set to empty then the data is stored in the database, useful for
  # diagnostics during report development.
  #
  # The tables are created in the order given and after any reporting
  # tables from the `main-tables` section above.
  report-tables:
    - servers

    - l1plugins-per-server
    - l1missing-plugins-per-server
    - l1covered-probes
    - l1covered-servers
    - l1covered-gateways

    - l2plugins-per-server
    - l2missing-plugins-per-server
    - l2covered-probes
    - l2covered-servers
    - l2covered-gateways

    - l3plugins-per-server
    - l3plugins-per-probe
    - l3covered-probes
    - l3covered-servers
    - l3covered-gateways

    - covered-gateways
    - unused-gateways
    - empty-gateways

    - covered-servers
    - uncovered-servers
    - empty-servers

    - covered-probes
    - empty-probes

    - match-gateways
    - match-servers
    - match-gateway-sources
    - match-sampler-plugins


  # `gdna-version` stores the version of gdna that the database was
  # created with. This will be used to perform schema updates in future
  # releases.
  gdna-version:
    table: gdna_version
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.gdna-version.table} (
        version        TEXT NOT NULL UNIQUE
      );
    insert: > #sql
      INSERT INTO ${db.gdna-version.table} (version)
        VALUES (@version)
        ON CONFLICT (version)
          DO UPDATE SET version = @version;
    query: | #sql
      SELECT version FROM ${db.gdna-version.table};

  # updates are run based on the current value of PRAGMA user_version
  #
  # each set of updates for values greater than the current value are
  # run and the value updated. each update is run in it's own
  # transaction and failure results in program termination.
  schema-updates:
    1:
      # if table already exists, then recreate it
      check: |
        SELECT count(*) BETWEEN 1 AND 4 FROM pragma_table_info('${db.gateways.table}')
      update: | #sql
        CREATE TABLE ${db.gateways.table}_new (
          gateway           TEXT NOT NULL COLLATE NOCASE,
          firstSeen         TIMESTAMP NOT NULL,
          lastSeen          TIMESTAMP NOT NULL,
          source            TEXT NOT NULL,

          UNIQUE (gateway, source)
        );
        INSERT INTO ${db.gateways.table}_new SELECT * FROM ${db.gateways.table};
        DROP TABLE ${db.gateways.table};
        ALTER TABLE ${db.gateways.table}_new RENAME TO ${db.gateways.table};
    2:
      # if ca_samplers_all has less than the expected columns, recreate
      check: | #sql
        SELECT count(*) BETWEEN 1 AND 14 FROM pragma_table_info('${db.ca-samplers.table}');
      update: | #sql
        CREATE TABLE ${db.ca-samplers.table}_new (
          gateway           TEXT NOT NULL COLLATE NOCASE,
          plugin            TEXT NOT NULL,
          entity            TEXT,
          number            INT NOT NULL,
          probeName         TEXT COLLATE NOCASE,
          probePort         INT,
          tokenID           TEXT,
          server            TEXT COLLATE NOCASE,
          hostID            TEXT,
          os                TEXT,
          version           TEXT,
          firstSeen         TIMESTAMP NOT NULL,
          lastSeen          TIMESTAMP NOT NULL,
          source            TEXT NOT NULL,
          UNIQUE (gateway, plugin, entity)
        );
        INSERT INTO ${db.ca-samplers.table}_new
          SELECT gateway, plugin, entity, number, NULL AS probeName, NULL AS probePort, NULL AS tokenID, NULL AS server, NULL AS hostID, NULL AS os, NULL AS version, firstSeen, lastSeen, source
            FROM ${db.ca-samplers.table};
        DROP TABLE ${db.ca-samplers.table};
        ALTER TABLE ${db.ca-samplers.table}_new RENAME TO ${db.ca-samplers.table};
        CREATE INDEX ${db.ca-samplers.table}_idx1 ON ${db.ca-samplers.table} (source, lastSeen DESC);
    3:
      check: | #sql
        SELECT count(*) = 4 FROM pragma_table_info('${db.gateways.table}')
      update: | #sql
        CREATE TABLE ${db.gateways.table}_new (
          gateway           TEXT NOT NULL COLLATE NOCASE,
          gatewayHost       TEXT,
          gatewayPort       INT,
          version           TEXT,
          firstSeen         TIMESTAMP NOT NULL,
          lastSeen          TIMESTAMP NOT NULL,
          source            TEXT NOT NULL,

          UNIQUE (gateway, source)
        );
        INSERT INTO ${db.gateways.table}_new
          SELECT gateway, NULL AS gatewayHost, NULL AS gatewayPort, NULL AS version, firstSeen, lastSeen, source
            FROM ${db.gateways.table};
        DROP TABLE ${db.gateways.table};
        ALTER TABLE ${db.gateways.table}_new RENAME TO ${db.gateways.table};
    4:
      check: | #sql
        SELECT version < 'v1.18' FROM ${db.gdna-version.table}
      update: | #sql
        CREATE TABLE IF NOT EXISTS ${plugins.level1.table}_new (
          plugin            TEXT NOT NULL
        );
        CREATE TABLE IF NOT EXISTS ${plugins.level1-optional.table}_new (
          plugin            TEXT NOT NULL
        );
        CREATE TABLE IF NOT EXISTS ${plugins.level2.table}_new (
          plugin            TEXT NOT NULL
        );

        INSERT INTO ${plugins.level1.table}_new SELECT * FROM ${plugins.level1.table};
        DROP TABLE ${plugins.level1.table};
        ALTER TABLE ${plugins.level1.table}_new RENAME TO ${plugins.level1.table};

        INSERT INTO ${plugins.level1-optional.table}_new SELECT * FROM ${plugins.level1-optional.table};
        DROP TABLE ${plugins.level1-optional.table};
        ALTER TABLE ${plugins.level1-optional.table}_new RENAME TO ${plugins.level1-optional.table};

        INSERT INTO ${plugins.level2.table}_new SELECT * FROM ${plugins.level2.table};
        DROP TABLE ${plugins.level2.table};
        ALTER TABLE ${plugins.level2.table}_new RENAME TO ${plugins.level2.table};

  #
  # main-tables
  #

  # the sources table tracks the first and last timestamps for each
  # source we collect data for.
  #
  # this is used for both reporting about sources but also to check if
  # the reporting database needs rebuilding
  #
  # sources are always unfiltered
  sources:
    table: sources
    columns: source, status, firstSeen, lastSeen, sourceType, path, valid
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.sources.table} (
        source            TEXT NOT NULL UNIQUE,
        status            TEXT NOT NULL,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        sourceType        TEXT NOT NULL,
        path              TEXT NOT NULL,
        valid             BOOL
      );
    insert: > #sql
      INSERT INTO ${db.sources.table}
               (source, status, sourceType, firstSeen, lastSeen, path, valid)
        VALUES (@source, @status, @sourceType, @firstSeen, @lastSeen, @path, @valid)
      ON CONFLICT (source)
        DO UPDATE SET sourceType=@sourceType, path=@path, lastSeen=@lastSeen, status=@status, valid=@valid
            WHERE excluded.lastSeen > lastSeen;

    update-valid: > #sql
      UPDATE ${db.sources.table} SET
          valid = unixepoch(lastSeen) >= @oldestValidTime AND source IN (${sources}),
          status = 
            CASE WHEN unixepoch(lastSeen) < @oldestValidTime AND status = "OK"
                  THEN "STALE: Not updated for more than " ||@maxAge
                WHEN unixepoch(lastSeen) >= @oldestValidTime AND status like 'STALE%'
                  THEN "OK"
                ELSE status
                END;

  # sources-licence is always unfiltered
  sources-licence:
    table: sources_licence
    columns: source, status, firstSeen, lastSeen, sourceType, path, valid
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.sources-licence.table} (
        source            TEXT NOT NULL UNIQUE,
        licenceexpiry     TIMESTAMP,
        licencemode       TEXT,
        licencename       TEXT,
        hostname          TEXT,
        hostid            TEXT
      );
    insert: | #sql
      INSERT INTO ${db.sources-licence.table}
              (source, licenceexpiry, licencemode, licencename, hostname, hostid)
        VALUES (@source, @licenceexpiry, @licencemode, @licencename, @hostname, @hostid)
      ON CONFLICT (source)
        DO UPDATE SET licenceexpiry=@licenceexpiry, licencemode=@licencemode, licencename=@licencename, hostname=@hostname, hostid=@hostid;

  # `reporting-updates` stores the time of the latest time from the last
  # fetch run. It cannot be a temporary table as it stores historical
  # data
  reporting-updates:
    table: reporting_updates
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.reporting-updates.table} (
        lastUpdate        TIMESTAMP NOT NULL
      );
    update: > #sql
      DELETE FROM ${db.reporting-updates.table};
      INSERT INTO ${db.reporting-updates.table} SELECT COALESCE(max(lastSeen), 'now') FROM ${db.sources.table};

  # the probes table contains entries for all netprobes, where
  # component = "binary" and item = "netprobe"
  probes:
    table: probes_all
    columns: gateway, probeName, probePort, server, hostID, firstSeen, lastSeen, source, os, version
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.probes.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        probeName         TEXT COLLATE NOCASE,
        probePort         INT,
        tokenID           TEXT,
        server            TEXT COLLATE NOCASE,
        hostID            TEXT,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        os                TEXT,
        version           TEXT,
        UNIQUE (gateway, probeName, probePort, tokenID)
      );
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx1 ON ${db.probes.table} (source, lastSeen DESC);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx2 ON ${db.probes.table} (gateway, tokenID, probeName);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx3 ON ${db.probes.table} (gateway, tokenID, probeName DESC);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx4 ON ${db.probes.table} (tokenID, probeName DESC);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx5 ON ${db.probes.table} (probeName);
      CREATE INDEX IF NOT EXISTS ${db.probes.table}_idx6 ON ${db.probes.table} (server);
    insert: > #sql
      INSERT INTO ${db.probes.table}
               (gateway, probeName, probePort, tokenID, firstSeen, lastSeen, source, os, version)
        VALUES (@gateway, @probeName, @probePort, @tokenID, @time, @time, @source, @os, @version)
        ON CONFLICT (gateway, probeName, probePort, tokenID)
          DO UPDATE SET lastSeen=@time, source=@source, os=COALESCE(@os, os), version=COALESCE(@version, version)
              WHERE excluded.lastSeen > lastSeen;
    # NOTE: we append the hostid so that multiple containers on the same host are distinguished
    post-insert: > #sql
      UPDATE ${db.probes.table} AS p
         SET hostID = tokenID,
             server = (SELECT lower(probeName)
                         FROM ${db.probes.table}
                        WHERE tokenID = p.tokenID
                        ORDER BY lower(probeName) IN ('localhost', '127.0.0.1'), probeName DESC
                       LIMIT 1)
                      || ':' || tokenID;
    active: probes
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.probes.active};
      CREATE ${db.temporary-table} TABLE ${db.probes.active} AS
        SELECT ${db.probes.columns}
          FROM ${db.probes.table} p
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = p.source AND valid)
           AND ${filters:p:gateway,source,server,hostid}
        ;
      CREATE INDEX IF NOT EXISTS ${db.probes.active}_idx1 ON ${db.probes.active} (server);

    inactive: probes_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.probes.inactive};
      CREATE ${db.temporary-table} TABLE ${db.probes.inactive} AS
        SELECT ${db.probes.columns}
          FROM ${db.probes.table} p
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = p.source AND valid)
           AND ${filters:p:gateway,source,server,hostid}
        ;

  samplers:
    # The samplers table contains all entries from the license daemon for
    # the "plugin" component, the plugin column being set to the "item"
    table: samplers_all
    columns: gateway, plugin, probeName, probePort, server, hostID, number, source, individual, firstSeen, lastSeen
    # the indexes below were suggested by SQLite ".expert" mode during
    # development and may need to be updated based on changes since
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.samplers.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        plugin            TEXT NOT NULL,
        probeName         TEXT COLLATE NOCASE,
        probePort         INT,
        tokenID           TEXT,
        hostID            TEXT,
        individual        BOOLEAN,
        server            TEXT COLLATE NOCASE,
        number            INT NOT NULL,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        UNIQUE (gateway, plugin, probeName, probePort, tokenID, lastSeen),
        UNIQUE (gateway, plugin, probeName, probePort, tokenID)
      );
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx1 ON ${db.samplers.table} (source, lastSeen DESC);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx2 ON ${db.samplers.table} (gateway, server, tokenID);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx3 ON ${db.samplers.table} (server, tokenID);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx4 ON ${db.samplers.table} (tokenID, probeName DESC);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx5 ON ${db.samplers.table} (gateway, tokenID, probeName);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx6 ON ${db.samplers.table} (probeName, gateway, server);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx7 ON ${db.samplers.table} (server, plugin);
      CREATE INDEX IF NOT EXISTS ${db.samplers.table}_idx8 ON ${db.samplers.table} (probeName, probePort, plugin);
    insert: | #sql
      INSERT INTO ${db.samplers.table}
             (gateway, plugin, probeName, probePort, tokenID, number, individual, firstSeen, lastSeen, source)
      VALUES (@gateway, @plugin, @probeName, @probePort, @tokenID, @number, @individual, @time, @time, @source)
        ON CONFLICT (gateway, plugin, probeName, probePort, tokenID, lastSeen)
          DO UPDATE SET number=number+@number WHERE hostID IS NULL
        ON CONFLICT (gateway, plugin, probeName, probePort, tokenID)
          DO UPDATE SET number=@number, source=@source, lastSeen=@time, hostID=NULL
              WHERE excluded.lastSeen > lastSeen;
    post-insert: | #sql
      UPDATE ${db.samplers.table} AS s
         SET server = (SELECT server
                         FROM ${db.probes.table}
                        WHERE gateway = s.gateway
                          AND probeName = s.probeName
                          AND probePort = s.probePort
                        ORDER BY lastSeen DESC
                        LIMIT 1),
             hostID = IIF(tokenID <> 'INDIVIDUAL',
                          tokenID,
                          (SELECT tokenID
                             FROM ${db.samplers.table}
                            WHERE (gateway, probeName) IN (SELECT DISTINCT gateway, probeName FROM ${db.samplers.table} WHERE tokenID <> 'INDIVIDUAL')
                              AND probeName = s.probeName
                              AND tokenID <> 'INDIVIDUAL'
                            LIMIT 1)
                         ),
             individual = IIF(tokenID = 'INDIVIDUAL', 1, NULL)
      ;
      -- ensure hostID is always set, even if the the subquery returns NULL - but use the final server name
      UPDATE ${db.samplers.table}
         SET hostID = server
       WHERE hostID IS NULL
      ;
    active: samplers
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.samplers.active};
      CREATE ${db.temporary-table} TABLE ${db.samplers.active} AS
        SELECT ${db.samplers.columns}
          FROM ${db.samplers.table} s
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = s.source AND valid)
           AND ${filters:s:gateway,source,server,plugin,hostid}
      ;
      CREATE INDEX IF NOT EXISTS ${db.samplers.active}_idx_1 ON ${db.samplers.active} (server);
      CREATE INDEX IF NOT EXISTS ${db.samplers.active}_idx_2 ON ${db.samplers.active} (probeName, probePort);
      CREATE INDEX IF NOT EXISTS ${db.samplers.active}_idx_3 ON ${db.samplers.active} (server, plugin);
      CREATE INDEX IF NOT EXISTS ${db.samplers.active}_idx_4 ON ${db.samplers.active} (gateway, probeName, probePort, plugin);

    inactive: samplers_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.samplers.inactive};
      CREATE ${db.temporary-table} TABLE ${db.samplers.inactive} AS
        SELECT ${db.samplers.columns}
          FROM ${db.samplers.table} s
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = s.source AND valid)
           AND ${filters:s:gateway,source,server,plugin,hostid}

      ;

  ca-samplers:
    # The ca-samplers table contains all entries from the license daemon for
    # the "ca-plugin" component, the plugin column being set to the "item"
    table: ca_samplers_all
    columns: gateway, plugin, entity, number, probeName, probePort, server, hostID, firstSeen, lastSeen, source
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.ca-samplers.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        plugin            TEXT NOT NULL,
        entity            TEXT,
        number            INT NOT NULL,
        probeName         TEXT COLLATE NOCASE,
        probePort         INT,
        tokenID           TEXT,
        server            TEXT COLLATE NOCASE,
        hostID            TEXT,
        os                TEXT,
        version           TEXT,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        UNIQUE (gateway, plugin, entity)
      );
      CREATE INDEX IF NOT EXISTS ${db.ca-samplers.table}_idx1 ON ${db.ca-samplers.table} (source, lastSeen DESC);
    insert: > #sql
      INSERT INTO ${db.ca-samplers.table}
               (gateway, plugin, entity, probeName, probePort, tokenID, hostID, number, firstSeen, lastSeen, source)
        VALUES (@gateway, @plugin, @entity, @probeName, @probePort, @tokenID, @tokenID, @number, @time, @time, @source)
        ON CONFLICT (gateway, plugin, entity)
          DO UPDATE SET number=@number, source=@source, lastSeen=@time, probeName=@probeName, probePort=@probePort, tokenID=@tokenID, hostID=@tokenID
              WHERE excluded.lastSeen > lastSeen;
    post-insert: > #sql
      UPDATE ${db.ca-samplers.table} AS s
         SET server = (SELECT server
                         FROM ${db.probes.table}
                        WHERE gateway = s.gateway
                          AND probeName = s.probeName
                          AND probePort = s.probePort
                        ORDER BY lastSeen DESC
                        LIMIT 1)
      ;

    active: ca_samplers
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.ca-samplers.active};
      CREATE ${db.temporary-table} TABLE ${db.ca-samplers.active} AS
        SELECT ${db.ca-samplers.columns}
          FROM ${db.ca-samplers.table} c
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = c.source AND valid)
           AND ${filters:c:gateway,source,server,plugin,hostid}
      ;
      CREATE INDEX IF NOT EXISTS ${db.ca-samplers.active}_idx_1 ON ${db.ca-samplers.active} (server, plugin);
      CREATE INDEX IF NOT EXISTS ${db.ca-samplers.active}_idx_2 ON ${db.ca-samplers.active} (gateway, probeName, probePort, plugin);
    inactive: ca_samplers_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.ca-samplers.inactive};
      CREATE ${db.temporary-table} TABLE ${db.ca-samplers.inactive} AS
        SELECT ${db.ca-samplers.columns}
          FROM ${db.ca-samplers.table} c
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = c.source AND valid)
           AND ${filters:c:gateway,source,server,plugin,hostid}
      ;

  gw-samplers:
    # The `gw-samplers` table contains all entries from the license
    # daemon for the "gateway-plugin" component, the plugin column
    # being set to the "item"
    table: gw_samplers_all
    columns: gateway, plugin, number, firstSeen, lastSeen, source
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.gw-samplers.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        plugin            TEXT NOT NULL,
        number            INT NOT NULL,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        UNIQUE (gateway, plugin)
      );
      CREATE INDEX IF NOT EXISTS ${db.gw-samplers.table}_idx1 ON ${db.gw-samplers.table} (source, lastSeen DESC);
    insert: > #sql
      INSERT INTO ${db.gw-samplers.table}
               (gateway, plugin, number, firstSeen, lastSeen, source)
        VALUES (@gateway, @plugin, @number, @time, @time, @source)
        ON CONFLICT (gateway, plugin)
          DO UPDATE SET number=@number, source=@source, lastSeen=@time
              WHERE excluded.lastSeen > lastSeen;
    active: gw_samplers
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.gw-samplers.active};
      CREATE ${db.temporary-table} TABLE ${db.gw-samplers.active} AS
        SELECT ${db.gw-samplers.columns}
          FROM ${db.gw-samplers.table} s
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = s.source AND valid)
           AND ${filters:s:gateway,source,plugin}
      ;
    inactive: gw_samplers_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.gw-samplers.inactive};
      CREATE ${db.temporary-table} TABLE ${db.gw-samplers.inactive} AS
        SELECT ${db.gw-samplers.columns}
          FROM ${db.gw-samplers.table} s
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = s.source AND valid)
           AND ${filters:s:gateway,source,plugin}
      ;

  gw-components:
    # The `gw-components` table contains all entries from the license
    # daemon for the "gateway_component" component, the plugin column
    # being set to the "item"
    table: gw_components_all
    columns: gateway, component, number, firstSeen, lastSeen, source
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.gw-components.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        component         TEXT NOT NULL,
        number            INT NOT NULL,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,
        UNIQUE (gateway, component)
      );
      CREATE INDEX IF NOT EXISTS ${db.gw-components.table}_idx1 ON ${db.gw-components.table} (source, lastSeen DESC);
    insert: > #sql
      INSERT INTO ${db.gw-components.table}
               (gateway, component, number, firstSeen, lastSeen, source)
        VALUES (@gateway, @component, @number, @time, @time, @source)
        ON CONFLICT (gateway, component)
          DO UPDATE SET number=@number, source=@source, lastSeen=@time
              WHERE excluded.lastSeen > lastSeen;
    active: gw_components
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.gw-components.active};
      CREATE ${db.temporary-table} TABLE ${db.gw-components.active} AS
        SELECT ${db.gw-components.columns}
          FROM ${db.gw-components.table} gwc 
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = gwc.source AND valid)
           AND ${filters:gwc:gateway,source}
      ;
    inactive: gw_components_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.gw-components.inactive};
      CREATE ${db.temporary-table} TABLE ${db.gw-components.inactive} AS
        SELECT ${db.gw-components.columns}
          FROM ${db.gw-components.table} gwc
         WHERE lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = gwc.source AND valid)
           AND ${filters:gwc:gateway,source}
      ;

  # gateways returns a single column table containing all known gateways
  # from the four samplers and probes tables
  gateways:
    table: gateways_all
    columns: gateway, gatewayHost, gatewayPort, version, firstSeen, lastSeen, source
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${db.gateways.table} (
        gateway           TEXT NOT NULL COLLATE NOCASE,
        gatewayHost       TEXT,
        gatewayPort       INT,
        version           TEXT,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,

        UNIQUE (gateway, source)
      );

    insert: > #sql
      INSERT INTO ${db.gateways.table}
              (gateway, gatewayHost, gatewayPort, version, firstSeen, lastSeen, source)
      VALUES (@gateway, @host, @port, @version, @time, @time, @source)
      ON CONFLICT (gateway, source)
        DO UPDATE SET gatewayHost=@host, gatewayPort=@port, version=@version, lastSeen=@time, source=@source
            WHERE excluded.lastSeen > lastSeen;
    filter:
      # include MUST default to a wildcard
      include: "*"
      # exclude MUST default to nothing
      exclude:
    active: gateways
    create-active: > #sql
      DROP TABLE IF EXISTS ${db.gateways.active};
      CREATE TABLE ${db.gateways.active} AS
        SELECT gateway, gatewayHost, gatewayPort, version, min(firstSeen) as firstSeen, max(lastSeen) as lastSeen, group_concat(source, ',') as source
          FROM ${db.gateways.table} gw
        WHERE gateway IN (
            SELECT DISTINCT gateway FROM ${db.samplers.active}
            UNION
            SELECT DISTINCT gateway FROM ${db.ca-samplers.active}
            UNION
            SELECT DISTINCT gateway FROM ${db.gw-samplers.active}
            UNION
            SELECT DISTINCT gateway FROM ${db.probes.active}
          )
          AND lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = gw.source AND valid)
          AND ${filters:gw:gateway,source}
        GROUP BY gateway
      ;
    inactive: gateways_previous
    create-inactive: > #sql
      DROP TABLE IF EXISTS ${db.gateways.inactive};
      CREATE TABLE ${db.gateways.inactive} AS
        SELECT gateway, gatewayHost, gatewayPort, version, min(firstSeen) as firstSeen, max(lastSeen) as lastSeen, group_concat(source, ',') as source
          FROM ${db.gateways.table} gw
        WHERE gateway IN (
            SELECT DISTINCT gateway FROM ${db.samplers.active}
            UNION
            SELECT DISTINCT gateway FROM ${db.ca-samplers.active}
            UNION
            SELECT DISTINCT gateway FROM ${db.gw-samplers.active}
            UNION
            SELECT DISTINCT gateway FROM ${db.probes.active}
          )
          AND lastSeen <> (SELECT lastSeen FROM ${db.sources.table} WHERE source = gw.source AND valid)
          AND ${filters:gw:gateway,source}
          GROUP BY gateway
      ;

  tokens:
    table: tokens_all
    columns: token, total, used, free, firstSeen, lastSeen, source
    create: | #sql
      CREATE TABLE IF NOT EXISTS ${db.tokens.table} (
        token             TEXT NOT NULL,
        total             NUMBER,
        used              NUMBER,
        free              NUMBER,
        firstSeen         TIMESTAMP NOT NULL,
        lastSeen          TIMESTAMP NOT NULL,
        source            TEXT NOT NULL,

        UNIQUE (token, source)
      );
    insert: | #sql
      INSERT INTO ${db.tokens.table}
                  (token, total, used, free, firstSeen, lastSeen, source)
      VALUES (@token, @total, @used, @free, @time, @time, @source)
      ON CONFLICT (token, source)
        DO UPDATE SET total=@total, used=@used, free=@free, lastSeen=@time
            WHERE excluded.lastSeen > lastSeen;
    active: tokens
    create-active: | #sql
      DROP TABLE IF EXISTS ${db.tokens.active};
      CREATE TABLE ${db.tokens.active} AS
        SELECT DISTINCT token, total, used, free, t.firstSeen firstSeen, t.lastSeen lastSeen, t.source source -- ${db.tokens.columns}
          FROM ${db.tokens.table} t, ${db.sources.table} s
         WHERE t.lastSeen = s.lastSeen AND s.valid = 1
      ;

  #
  # report-tables
  #

  # report tables have filters applied in the source tables they query.
  # Make sure that all source tables used "active" and not "table" in
  # the identifier, when they exist.

  # The `servers` table is built from the probes on all valid sources
  # grouped by gateway and source. The server name is resolved in the
  # `db.probes.post-insert` query which is run after all probes are
  # loaded.
  servers:
    table: servers
    columns: gateway, server, hostID, firstSeen, lastSeen, source, os, version
    create: > #sql
      DROP TABLE IF EXISTS ${db.servers.table};
      CREATE ${db.temporary-table} TABLE ${db.servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.probes.active}
         WHERE lastSeen = (SELECT lastSeen FROM ${db.sources.table} WHERE source = ${db.probes.active}.source AND valid)
         GROUP BY gateway, server
      ;
      CREATE INDEX IF NOT EXISTS ${db.servers.table}_idx_1 ON ${db.servers.table}(server, gateway);
      CREATE INDEX IF NOT EXISTS ${db.servers.table}_idx_2 ON ${db.servers.table}(gateway, server);

  # the `l1plugins-per-server` table is built from all active samplers
  # that match the plugin names in the `level1` table and is then
  # grouped by gateway, server and plugin.
  l1plugins-per-server:
    table: l1_plugins_server
    columns: gateway, plugin, server, hostID, number, source, individual, firstSeen, lastSeen
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1plugins-per-server.table};
      CREATE ${db.temporary-table} TABLE ${db.l1plugins-per-server.table} AS
        SELECT gateway, plugin, server, hostID, sum(number) as number, source, individual, firstSeen, lastSeen
          FROM ${db.samplers.active}
        WHERE plugin IN ${plugins.level1.table}
        GROUP BY server, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l1plugins-per-server.table}_idx_1 ON ${db.l1plugins-per-server.table}(server);

  l1missing-plugins-per-server:
    table: l1_missing_plugins_server
    columns: server, plugin, missing
    create: | #sql
      DROP TABLE IF EXISTS ${db.l1missing-plugins-per-server.table};
      CREATE ${db.temporary-table} TABLE ${db.l1missing-plugins-per-server.table} AS
        WITH baseline(server, plugin, needed) AS (
          SELECT server, l1.plugin, (SELECT count(*) FROM ${plugins.level1.table} WHERE plugin = l1.plugin)
            FROM ${db.servers.table}
            RIGHT JOIN ${plugins.level1.table} l1
            GROUP BY server, l1.plugin
        )
        SELECT server, plugin, printf('%d', needed - total(number)) missing
          FROM baseline
          LEFT JOIN ${db.samplers.active} USING (server, plugin)
        GROUP BY baseline.server, plugin
        HAVING needed > total(number)
      ;
      CREATE INDEX IF NOT EXISTS ${db.l1missing-plugins-per-server.table}_idx_1 ON ${db.l1missing-plugins-per-server.table}(server);

  # the `l1covered-*` tables are built from active probes / samplers /
  # gateways where the number of DISTINCT plugins match the number in
  # the `level1` table. Each is grouped by gateway and then either the
  # probe host & port or server, as appropriate.
  l1covered-probes:
    table: l1covered_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1covered-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.l1covered-probes.table} AS
      SELECT ${db.probes.columns}
        FROM ${db.probes.active}
       WHERE (probeName, probePort) NOT IN (
        WITH baseline(probeName, probePort, plugin, needed) AS (
          SELECT  probeName,
                  probePort,
                  l1.plugin,
                  (SELECT count(*) FROM ${plugins.level1.table} WHERE plugin = l1.plugin )
            FROM ${db.probes.active}
            RIGHT JOIN ${plugins.level1.table} l1
            GROUP BY server, l1.plugin
        )
        SELECT DISTINCT probeName, probePort
          FROM baseline
          LEFT JOIN ${db.samplers.active} USING (probeName, probePort, plugin)
         GROUP BY baseline.probeName, baseline.probePort, plugin
        HAVING needed > total(number)
       )
       GROUP BY gateway, probeName, probePort;

  l1covered-servers:
    table: l1covered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1covered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.l1covered-servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
         WHERE server NOT IN (SELECT DISTINCT server FROM ${db.l1missing-plugins-per-server.table})
         GROUP BY gateway, server;
        CREATE INDEX IF NOT EXISTS ${db.l1covered-servers.table}_idx_1 ON ${db.l1covered-servers.table}(gateway);

  l1covered-gateways:
    table: l1covered_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.l1covered-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.l1covered-gateways.table} AS
      SELECT ${db.gateways.columns}
        FROM ${db.gateways.active}
        WHERE gateway IN (
          SELECT gateway
            FROM ${db.l1covered-servers.table} l1s
           GROUP BY gateway
          HAVING count(*) = (SELECT count(*) FROM servers WHERE gateway = l1s.gateway)
        )

  l2plugins-per-server:
    table: l2_plugins_server
    columns: gateway, plugin, server, hostID, number, source, individual, firstSeen, lastSeen
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2plugins-per-server.table};
      CREATE ${db.temporary-table} TABLE ${db.l2plugins-per-server.table} AS
        SELECT gateway, plugin, server, hostID, sum(number) as number, source, individual, firstSeen, lastSeen
          FROM ${db.samplers.active}
        WHERE plugin IN ${plugins.level2.table}
        GROUP BY gateway, server, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l2plugins-per-server.table}_idx_1 ON ${db.l2plugins-per-server.table}(server);

  l2missing-plugins-per-server:
    table: l2_missing_plugins_server
    columns: server, plugin, missing
    create: | #sql
      DROP TABLE IF EXISTS ${db.l2missing-plugins-per-server.table};
      CREATE ${db.temporary-table} TABLE ${db.l2missing-plugins-per-server.table} AS
        WITH baseline(server, plugin, needed) AS (
          SELECT server, l2.plugin, (SELECT count(*) FROM ${plugins.level2.table} WHERE plugin = l2.plugin)
            FROM ${db.servers.table}
            RIGHT JOIN ${plugins.level2.table} l2
            GROUP BY server, l2.plugin
        )
        SELECT server, plugin, printf('%d', needed - total(number)) missing
          FROM baseline
          LEFT JOIN ${db.samplers.active} USING (server, plugin)
        GROUP BY baseline.server, plugin
        HAVING needed > total(number)
      ;
      CREATE INDEX IF NOT EXISTS ${db.l2missing-plugins-per-server.table}_idx_1 ON ${db.l2missing-plugins-per-server.table}(server);

  l2covered-probes:
    table: l2covered_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2covered-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.l2covered-probes.table} AS
      SELECT ${db.probes.columns}
        FROM ${db.probes.active}
       WHERE (probeName, probePort) NOT IN (
        WITH baseline(probeName, probePort, plugin, needed) AS (
          SELECT  probeName,
                  probePort,
                  l2.plugin,
                  (SELECT count(*) FROM ${plugins.level2.table} WHERE plugin = l2.plugin )
            FROM ${db.probes.active}
           RIGHT JOIN ${plugins.level2.table} l2
           GROUP BY server, l2.plugin
        )
        SELECT DISTINCT probeName, probePort
          FROM baseline
          LEFT JOIN ${db.samplers.active} USING (probeName, probePort, plugin)
         GROUP BY baseline.probeName, baseline.probePort, plugin
        HAVING needed > total(number)
       )
       GROUP BY gateway, probeName, probePort;

  l2covered-servers:
    table: l2covered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2covered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.l2covered-servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
         WHERE server NOT IN (SELECT DISTINCT server FROM ${db.l2missing-plugins-per-server.table})
         GROUP BY gateway, server;
      CREATE INDEX IF NOT EXISTS ${db.l2covered-servers.table}_idx_1 ON ${db.l2covered-servers.table}(gateway);

  l2covered-gateways:
    table: l2covered_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.l2covered-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.l2covered-gateways.table} AS
      SELECT ${db.gateways.columns}
        FROM ${db.gateways.active}
        WHERE gateway IN (
          SELECT gateway
            FROM ${db.l2covered-servers.table} l2s
           GROUP BY gateway
          HAVING count(*) = (SELECT count(*) FROM servers WHERE gateway = l2s.gateway)
        )
        GROUP BY gateway;

  l3plugins-per-probe:
    table: l3_plugins_probe
    create: | #sql
      DROP TABLE IF EXISTS ${db.l3plugins-per-probe.table};
      CREATE ${db.temporary-table} TABLE ${db.l3plugins-per-probe.table} AS
        SELECT ${db.samplers.columns}
          FROM ${db.samplers.active}
        WHERE plugin NOT IN ${plugins.level1.table}
          AND plugin NOT IN ${plugins.level1-optional.table}
          AND plugin NOT IN ${plugins.level2.table}
        GROUP BY gateway, probeName, probePort, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l3plugins-per-probe.table}_idx_2 ON ${db.l3plugins-per-probe.table}(probeName, probePort);

  l3plugins-per-server:
    table: l3_plugins_server
    columns: gateway, plugin, server, hostID, number, source, individual, firstSeen, lastSeen
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3plugins-per-server.table};
      CREATE ${db.temporary-table} TABLE ${db.l3plugins-per-server.table} AS
        SELECT gateway, plugin, server, hostID, sum(number) as number, source, individual, firstSeen, lastSeen
          FROM ${db.samplers.active}
        WHERE plugin NOT IN ${plugins.level1.table}
          AND plugin NOT IN ${plugins.level1-optional.table}
          AND plugin NOT IN ${plugins.level2.table}
        GROUP BY gateway, server, plugin;
      CREATE INDEX IF NOT EXISTS ${db.l3plugins-per-server.table}_idx_1 ON ${db.l3plugins-per-server.table}(server);

  l3covered-probes:
    table: l3covered_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3covered-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.l3covered-probes.table} AS
      SELECT ${db.probes.columns}
        FROM ${db.probes.active}
       WHERE (probeName, probePort) IN (
          SELECT DISTINCT probeName, probePort
            FROM ${db.samplers.active}
           WHERE plugin NOT IN ${plugins.level1.table}
             AND plugin NOT IN ${plugins.level1-optional.table}
             AND plugin NOT IN ${plugins.level2.table}
           GROUP BY gateway, probeName, probePort, plugin
       )
       GROUP BY gateway, probeName, probePort;

  l3covered-servers:
    table: l3covered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3covered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.l3covered-servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
        WHERE server IN (SELECT DISTINCT server FROM ${db.l3plugins-per-server.table})
        GROUP BY gateway, server;
      CREATE INDEX IF NOT EXISTS ${db.l3covered-servers.table}_idx_1 ON ${db.l3covered-servers.table}(gateway);

  l3covered-gateways:
    table: l3covered_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.l3covered-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.l3covered-gateways.table} AS
      SELECT ${db.gateways.columns}
        FROM ${db.gateways.active}
       WHERE gateway IN (
          SELECT gateway FROM (
            SELECT gateway
              FROM ${db.l3plugins-per-server.table}
             GROUP BY gateway, server
          ) AS l3a
           GROUP BY gateway
          HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} WHERE gateway = l3a.gateway)
       )
       GROUP BY gateway;

  covered-gateways:
    table: covered_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.covered-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.covered-gateways.table} AS
      SELECT ${db.gateways.columns}
        FROM ${db.gateways.active}
        WHERE gateway IN (SELECT gateway FROM ${db.l1covered-gateways.table})
          AND gateway IN (SELECT gateway FROM ${db.l2covered-gateways.table})
          AND gateway IN (SELECT gateway FROM ${db.l3covered-gateways.table})
       GROUP BY gateway
      HAVING count(*) = (SELECT count(*) FROM ${db.servers.table} WHERE gateway = ${db.gateways.active}.gateway);

  empty-gateways:
    table: empty_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.empty-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.empty-gateways.table} AS
      SELECT gateway, min(firstSeen) as firstSeen, max(lastSeen) as lastSeen, group_concat(source, ',') as source
        FROM ${db.gateways.active}
        WHERE gateway NOT IN (SELECT DISTINCT gateway FROM ${db.samplers.active})
          AND gateway NOT IN (SELECT DISTINCT gateway FROM ${db.ca-samplers.active})
          AND gateway NOT IN (SELECT DISTINCT gateway FROM ${db.gw-samplers.active})
        GROUP BY gateway;

  # `unused-gateways` includes all gateways that are not referenced by
  # an active server
  unused-gateways:
    table: unused_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.unused-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.unused-gateways.table} AS
      SELECT gateway, min(firstSeen) as firstSeen, max(lastSeen) as lastSeen, group_concat(source, ',') as source
        FROM ${db.gateways.active}
       WHERE gateway NOT IN (SELECT DISTINCT gateway FROM ${db.servers.table})
         AND gateway NOT IN (SELECT DISTINCT gateway FROM ${db.samplers.active})
         AND gateway NOT IN (SELECT DISTINCT gateway FROM ${db.ca-samplers.active})
         AND gateway NOT IN (SELECT DISTINCT gateway FROM ${db.gw-samplers.active})
       GROUP BY gateway;

  covered-servers:
    table: covered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.covered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.covered-servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
          WHERE server IN (SELECT server FROM ${db.l1covered-servers.table})
            AND server IN (SELECT server FROM ${db.l2covered-servers.table})
            AND server IN (SELECT server FROM ${db.l3covered-servers.table})
        ;

  uncovered-servers:
    table: uncovered_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.uncovered-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.uncovered-servers.table} AS
        SELECT ${db.servers.columns}
          FROM ${db.servers.table}
         WHERE server NOT IN (SELECT server FROM ${db.l1covered-servers.table})
            OR server NOT IN (SELECT server FROM ${db.l2covered-servers.table})
            OR server NOT IN (SELECT server FROM ${db.l3covered-servers.table});
        CREATE INDEX IF NOT EXISTS ${db.uncovered-servers.table}_idx_1 ON ${db.uncovered-servers.table}(server);

  empty-servers:
    table: empty_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.empty-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.empty-servers.table} AS
      SELECT ${db.servers.columns}
        FROM ${db.servers.table}
        WHERE server NOT IN (SELECT DISTINCT server FROM ${db.samplers.active})
          AND server NOT IN (SELECT DISTINCT server FROM ${db.ca-samplers.active});

  covered-probes:
    table: covered_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.covered-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.covered-probes.table} AS
        SELECT ${db.probes.columns}
          FROM ${db.probes.active}
          WHERE (probeName, probePort) IN (SELECT probeName, probePort FROM ${db.l1covered-probes.table})
            AND (probeName, probePort) IN (SELECT probeName, probePort FROM ${db.l2covered-probes.table})
            AND (probeName, probePort) IN (SELECT probeName, probePort FROM ${db.l3covered-probes.table});

  empty-probes:
    table: empty_probes
    create: > #sql
      DROP TABLE IF EXISTS ${db.empty-probes.table};
      CREATE ${db.temporary-table} TABLE ${db.empty-probes.table} AS
      SELECT ${db.probes.columns}
        FROM ${db.probes.active}
        WHERE (probeName, probePort) NOT IN (SELECT DISTINCT probeName, probePort FROM ${db.samplers.active});

  # the `match` tables, used to join to queries for grouping

  match-gateways:
    table: match_gateways
    create: > #sql
      DROP TABLE IF EXISTS ${db.match-gateways.table};
      CREATE ${db.temporary-table} TABLE ${db.match-gateways.table} AS
        SELECT DISTINCT grouping, gw.gateway
          FROM ${filters.group.gateway.table} grouping
          LEFT JOIN ${db.gateways.active} gw ON glob(grouping.gateway, gw.gateway);

  match-servers:
    table: match_servers
    create: > #sql
      DROP TABLE IF EXISTS ${db.match-servers.table};
      CREATE ${db.temporary-table} TABLE ${db.match-servers.table} AS
        SELECT DISTINCT grouping, srv.server
          FROM ${filters.group.server.table} grouping
          LEFT JOIN ${db.servers.table} srv ON glob(grouping.server, srv.server);

  match-gateway-sources:
    table: match_gateway_sources
    create: > #sql
      DROP TABLE IF EXISTS ${db.match-gateway-sources.table};
      CREATE ${db.temporary-table} TABLE ${db.match-gateway-sources.table} AS
        SELECT DISTINCT grouping, gw.source
          FROM ${filters.group.source.table} grouping
          LEFT JOIN ${db.gateways.active} gw ON glob(grouping.source, gw.source);

  match-sampler-plugins:
    table: match_sampler_plugins
    create: > #sql
      DROP TABLE IF EXISTS ${db.match-sampler-plugins.table};
      CREATE ${db.temporary-table} TABLE ${db.match-sampler-plugins.table} AS
        SELECT grouping, COALESCE(s.plugin, c.plugin, g.plugin) plugin
            FROM ${filters.group.plugin.table} grouping
            LEFT JOIN ${db.samplers.table} s ON glob(grouping.plugin, s.plugin)
            LEFT JOIN ${db.ca-samplers.table} c ON glob(grouping.plugin, c.plugin)
            LEFT JOIN ${db.gw-samplers.table} g ON glob(grouping.plugin, g.plugin)
          GROUP BY grouping, COALESCE(s.plugin, c.plugin, g.plugin, "")
      ;

# plugins is a list of the tables to create for levels of plugin
# coverage.
plugins:
  all:
    table: all_plugins
    create: | #sql
      CREATE TABLE IF NOT EXISTS ${plugins.all.table} (
        plugin            TEXT UNIQUE ON CONFLICT IGNORE NOT NULL
      );
    plugins:
      - alerting
      - api
      - api-streams
      - aws-plugin
      - azure-plugin
      - bloomberg-bpipe
      - clearvision-status
      - compute-engine
      - control-m
      - cpu
      - desktop-pc-monitoring
      - deviceio
      - disk
      - dynamic-entities-health
      - e4jms-bridges
      - e4jms-connections
      - e4jms-durables
      - e4jms-non-durables
      - e4jms-queues
      - e4jms-routes
      - e4jms-server
      - e4jms-topics
      - e4jms-usersummary
      - extractor
      - fidessa
      - fidessa-dq
      - fix-analyser2
      - fkm
      - flm
      - floating-probes
      - fluentdforward-plugin
      - ftm
      - gcp-plugin
      - gl-router
      - hardware
      - ibmi-file-member
      - ibmi-jdbc
      - ibmi-job
      - ibmi-logreader
      - ibmi-member-record
      - ibmi-message
      - ibmi-pool
      - ibmi-queue
      - ibmi-subsystem
      - ibmi-system
      - ipc
      - ix-ma
      - jdbc-plugin
      - jmx-server
      - jmx-threadinfo
      - kafka-plugin
      - kubernetes-plugin
      - market-data-monitor
      - message-tracker
      - mibmon
      - mongodb-plugin
      - mq-channel
      - mq-qinfo
      - mq-queue
      - net-ping
      - network
      - nyxt-papastats
      - op5monitor
      - opentelemetry-plugin
      - oracle
      - orc
      - perfmon
      - postgres-plugin
      - processes
      - prometheus-plugin
      - prometheus-target-plugin
      - publisher
      - reporting
      - rest-api
      - rest-extractor
      - rmc-interface
      - self-announcing-probes
      - sql-toolkit
      - statetracker
      - statsd-plugin
      - sybase
      - sybase-server
      - system-plugin
      - tcp-links
      - tib-rv
      - tib-rvpublisher
      - tib-rvstream
      - toolkit
      - top
      - trading-technologies
      - trapmon
      - unix-users
      - uptrends
      - veritas-cluster-server
      - web-mon
      - winapps
      - win-cluster
      - win-services
      - wmi
      - wts-licenses
      - wts-processes
      - wts-sessions
      - wts-summary
      - x-broadcast
      - x-mcast
      - x-multicast
      - x-ping
      - x-route
      - x-services
      - x-top
      - x-traffic
      - zookeeper-plugin

  # level1 is basic hardware / infrastructure
  #
  # there are actively four mandatory plugins and a number of
  # optional plugins. the optional plugins play no part in deciding if
  # a probe or gateway is covered for level 1 but are instead are used
  # to remove those plugins from the level 3 tests further below.
  level1:
    table: level1_plugins
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${plugins.level1.table} (
        plugin            TEXT NOT NULL
      );
    plugins: [ cpu, disk, network, hardware ]

  level1-optional:
    table: level1_optional_plugins
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${plugins.level1-optional.table} (
        plugin            TEXT NOT NULL
      );
    plugins: [ deviceio, ipc, top, unix-users, winapps, win-cluster, win-services, wmi, wts-licenses, wts-processes, wts-sessions, wts-summary ]

  # level 2 plugins are actively fkm (logs) and processes
  level2:
    table: level2_plugins
    create: > #sql
      CREATE TABLE IF NOT EXISTS ${plugins.level2.table} (
        plugin            TEXT NOT NULL
      );
    plugins: [ fkm, processes ]

reports:
  # This is the Summary sheet at the start of any XLSX file and as a
  # table in the body of emails. Put any required headlines here as they
  # are not added to individual sheets in an XLSX workbook.
  gdna-summary:
    name: GDNA Summary
    dataview:
      group: GDNA Information
    columns: [ Item, Description ]
    type: summary
    query: | #sql
      SELECT 'ITRS GDNA', 'Version ${gdna.version}'

      UNION ALL

      SELECT 'Site', '${gdna.site-name}'

      UNION ALL

      SELECT 'Report Time', '${datetime}'

      UNION ALL

      SELECT 'Created On', '${hostname}'

      UNION ALL
      
      SELECT 'Created By', '${username}'

      UNION ALL

      SELECT 'Valid/OK Licence Sources', (SELECT count(*) FROM ${db.sources.table} WHERE valid AND status = 'OK')

      UNION ALL

      SELECT 'Gateways', (SELECT count(*) FROM ${db.gateways.active}) || " (" || (SELECT count(*) FROM ${db.gateways.table}) || ")"

      UNION ALL

      SELECT 'Gateways - Unused', (SELECT count(DISTINCT gateway) FROM ${db.unused-gateways.table})

      UNION ALL

      SELECT 'Servers', (SELECT count(DISTINCT server) FROM ${db.servers.table})

      UNION ALL

      SELECT 'Probes', (SELECT count(*) FROM ${db.probes.active}) || " ("|| (SELECT count(*) FROM ${db.probes.table}) || ")"

      UNION ALL

      SELECT 'Samplers', (SELECT total(number) FROM ${db.samplers.active})

      UNION ALL

      SELECT 'Dynamic Entities', (SELECT total(number) FROM ${db.ca-samplers.active})

      UNION ALL

      SELECT 'Gateway Samplers', (SELECT total(number) FROM ${db.gw-samplers.active})
      ;

  coverage-by-level-and-plugin:
    name: Coverage By Level And Plugin
    dataview:
      group: Monitoring Coverage
    xlsx:
      enable: false
    columns: [ "level # plugin", instances, servers, "servers %", remainingServers, "remainingServers %" ]
    headlines: > #sql
      SELECT 'totalServers', (SELECT count(DISTINCT server) FROM ${db.servers.table});
    query: | #sql
      WITH totals AS (
        SELECT
             (SELECT count(DISTINCT server) FROM ${db.l1plugins-per-server.table}) l1count,
             (SELECT count(DISTINCT server) FROM ${db.l2plugins-per-server.table}) l2count,
             (SELECT count(DISTINCT server) FROM ${db.l3plugins-per-server.table}) l3count,
             (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table}) l1covered,
             (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table}) l2covered,
             (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table}) l3covered,
             (SELECT count(DISTINCT server) FROM ${db.servers.table}) servers
      ), l1 AS (
        SELECT
             plugin,
             (SELECT total(number) FROM ${db.l1plugins-per-server.table} WHERE plugin = l1.plugin) total,
             (SELECT count(DISTINCT server) FROM (SELECT * FROM ${db.l1plugins-per-server.table} WHERE plugin = l1.plugin)) covered
          FROM ${plugins.level1.table} l1
      ), l2 AS (
        SELECT
             plugin,
             (SELECT total(number) FROM ${db.l2plugins-per-server.table} WHERE plugin = l2.plugin) total,
             (SELECT count(*) FROM ${db.l2plugins-per-server.table}) count,
             (SELECT count(*) FROM (SELECT DISTINCT server FROM ${db.l2plugins-per-server.table} WHERE plugin = l2.plugin)) covered
          FROM ${plugins.level2.table} l2
      )
      SELECT 'level1',
             totals.l1count,
             totals.l1covered,
             printf('%d %%', round((totals.l1covered * 100.0 ) / totals.servers)),
             totals.l1count - totals.l1covered,
             printf('%d %%', 100 - round((totals.l1covered * 100.0 ) / totals.servers))
        FROM totals

      UNION ALL

      SELECT 'level1 # ' || plugin,
             l1.total,
             l1.covered,
             printf('%d %%', round((l1.covered * 100.0 ) / totals.servers)),
             totals.l1count - l1.covered,
             printf('%d %%', 100 - round((l1.covered * 100.0 ) / totals.servers))

        FROM totals, l1

      UNION ALL

      SELECT 'level2',
             totals.l2count,
             totals.l2covered,
             printf('%d %%', round((totals.l2covered * 100.0 ) / totals.servers)),
             totals.l2count - totals.l2covered,
             printf('%d %%', 100 - round((totals.l2covered * 100.0 ) / totals.servers))
        FROM totals

      UNION ALL

      SELECT 'level2 # ' || plugin,
             l2.total,
             l2.covered,
             printf('%d %%', round((l2.covered * 100.0 ) / totals.servers)),
             totals.l2count - l2.covered,
             printf('%d %%', 100 - round((l2.covered * 100.0 ) / totals.servers))

        FROM totals, l2

      UNION ALL

      SELECT 'level3',
             totals.l3count,
             totals.l3covered,
             printf('%d %%', round((totals.l3covered * 100.0 ) / totals.servers)),
             totals.servers - totals.l3covered,
             printf('%d %%', 100 - round((totals.l3covered * 100.0 ) / totals.servers))
        FROM totals;
              
  gateway-groups:
    name: Gateway Groups
    dataview:
      group: Groups
    xlsx:
      freeze-to-column: servers
    columns: [ group, gateways, servers, serverTokenAllocation, "serverTokenUsage %", complete, "complete %", empty, "empty %", remaining, "remaining %", l1complete, "l1complete %", l1remaining, l2complete, "l2complete %", l2remaining, l3complete, "l3complete %" ]
    query: | #sql
      WITH coverage(grouping, total, covered, empty, l1covered, l2covered, l3covered) AS (
        SELECT COALESCE(grouping, 'OTHER'),
               count(DISTINCT a.gateway) total,
               count(DISTINCT m.gateway) covered,
               count(DISTINCT e.gateway) empty,
               count(DISTINCT l1.gateway) l1covered,
               count(DISTINCT l2.gateway) l2covered,
               count(DISTINCT l3.gateway) l3covered
          FROM      ${db.gateways.active} a
          LEFT JOIN ${db.covered-gateways.table} m USING (gateway)
          LEFT JOIN ${db.empty-gateways.table} e USING (gateway)
          LEFT JOIN ${db.l1covered-gateways.table} l1 USING (gateway)
          LEFT JOIN ${db.l2covered-gateways.table} l2 USING (gateway)
          LEFT JOIN ${db.l3covered-gateways.table} l3 USING (gateway)
          LEFT JOIN ${db.match-gateways.table} grp USING (gateway)
        GROUP BY grouping
      ),
      s(grouping, servers) AS (
        SELECT grouping, count(DISTINCT server)
          FROM ${db.servers.table}
          LEFT JOIN ${db.match-gateways.table} grp USING (gateway)
         -- WHERE CASE WHEN grouping IS NULL THEN coverage.grouping IS NULL ELSE grouping = coverage.grouping END
         GROUP BY grouping
        UNION
        SELECT 'OTHER', count(DISTINCT server)
          FROM ${db.servers.table}
         WHERE gateway NOT IN (SELECT DISTINCT gateway FROM ${db.match-gateways.table})
      ),
      a(grouping, allocation) AS (
        SELECT COALESCE(grouping, 'OTHER'), allocation
          FROM ${filters.allocations.gateway.table}
         WHERE token = 'server'
         GROUP BY grouping
      )
      SELECT DISTINCT
             grouping,
             COALESCE(total, 0),
             COALESCE(servers, 0),
             COALESCE(allocation, 0),
             CASE WHEN allocation > 0 THEN
              printf('%d %%', round(COALESCE(servers, 0) * 100.0 / allocation))
             ELSE
              '0 %'
             END,
             COALESCE(covered, 0),
             printf('%d %%', round(covered * 100.0 / total)) coveredPercent,
             COALESCE(empty, 0),
             printf('%d %%', round(empty * 100.0 / total)) emptyPercent,
             COALESCE(total - covered - empty , 0) remaining,
             printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,
             COALESCE(l1covered - covered, 0),
             printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
             COALESCE(total - l1covered - empty, 0) l1remaining,
             COALESCE(l2covered - covered, 0),
             printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
             COALESCE(total - l2covered - empty, 0) l2remaining,
             COALESCE(l3covered - covered, 0),
             printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent
        FROM coverage
        LEFT JOIN s USING (grouping)
        LEFT JOIN a USING (grouping)
       RIGHT JOIN ${db.match-gateways.table} USING (grouping)
       ORDER BY CASE grouping WHEN 'OTHER' THEN 'ZZZZZZ' ELSE grouping END COLLATE NOCASE
      ;

  plugin-groups:
    name: Plugin Groups
    dataview:
      group: Groups
    xlsx:
      enable: false
    columns: [ pluginGroup, servers, instances ]
    query: | #sql
      WITH
        plugins AS (
          SELECT * FROM (
            SELECT DISTINCT gateway, plugin, server FROM ${db.samplers.active}
            UNION ALL
            SELECT DISTINCT gateway, plugin, entity server FROM ${db.ca-samplers.active}
            UNION ALL
            SELECT DISTINCT gateway, plugin, 1 server FROM ${db.gw-samplers.active}
           )
        )
      SELECT grouping,
             COALESCE(count(DISTINCT gateway||":"||server), 0) servers,
             COALESCE(count(server), 0) instances
        FROM plugins
        RIGHT JOIN ${db.match-sampler-plugins.table} USING (plugin)
       GROUP BY grouping
       ORDER BY grouping
      ;

  plugin-licences-per-gateway:
    name: Plugin Licences Per Gateway
    dataview:
      group: Licensing
      enable: false
    xlsx:
      enable: false
    columns: [] # none for indirect reports
    type: indirect
    query: | #sql
      WITH
        plugins AS (
          SELECT * FROM (
            SELECT DISTINCT plugin FROM ${db.samplers.active} WHERE individual IS NULL
            UNION ALL
            SELECT DISTINCT plugin FROM ${db.ca-samplers.active}
            UNION ALL
            SELECT DISTINCT plugin FROM ${db.gw-samplers.active}
           )
           ORDER BY (SELECT CASE
                      WHEN plugin IN ${plugins.level1.table} THEN 1
                      WHEN plugin IN ${plugins.level2.table} THEN 2
                      WHEN plugin IN ${plugins.level1-optional.table} THEN 3
                      WHEN plugin IN (SELECT DISTINCT plugin FROM ${db.gw-samplers.active}) THEN 5
                      WHEN plugin IN (SELECT DISTINCT plugin FROM ${db.ca-samplers.active}) THEN 6
                      ELSE 4 END), plugin
          
        ),
        lines AS (
          SELECT 'SELECT gateway, (SELECT count(*) FROM ${db.servers.table} q WHERE q.gateway = p.gateway) AS servers' AS parts

          UNION ALL

          SELECT ', total(number) FILTER (WHERE plugin = ''' || plugin || ''') AS ''' || plugin || '''' FROM plugins

          UNION ALL

          SELECT ' FROM ${db.samplers.active} AS p GROUP BY gateway'
        )
      SELECT group_concat(parts, '') FROM lines;

  instance-licences-per-gateway:
    name: Instance Licences Per Gateway
    dataview:
      group: Licensing
    xlsx:
      freeze-to-column: gateway
    columns: [] # none for indirect reports
    type: indirect
    query: | #sql
      WITH
        plugins AS (
            SELECT DISTINCT plugin FROM ${db.samplers.active} WHERE individual ORDER by plugin
        ),
        lines AS (
          SELECT 'SELECT gateway, (SELECT count(*) FROM ${db.servers.table} q WHERE q.gateway = p.gateway) AS servers' AS parts

          UNION ALL

          SELECT ', total(number) FILTER (WHERE plugin = ''' || plugin || ''') AS ''' || plugin || '''' FROM plugins

          UNION ALL

          SELECT ' FROM ${db.samplers.active} AS p GROUP BY gateway'
        )
      SELECT group_concat(parts, '') FROM lines;

  plugins:
    name: Plugins
    dataview:
      group: Geneos Estate
    xlsx:
      freeze-to-column: plugin 
    columns: [ plugin, servers, instances, tokensAvailable, tokensUsed, tokensUsedPct, previousServers, previousInstances, location, required, level, license, t1 ]
    headlines: > #sql
      SELECT 'totalServers', (SELECT count(DISTINCT server) FROM ${db.servers.table});
    query: | #sql
      WITH
      levels(plugin, required, level) AS (
        SELECT plugin,
              CASE
                WHEN plugin IN ${plugins.level1.table} OR plugin IN ${plugins.level2.table} THEN 'Required'
                ELSE 'Optional'
              END,
              CASE
                WHEN plugin IN ${plugins.level1.table} OR plugin IN ${plugins.level1-optional.table} THEN '1'
                WHEN plugin IN ${plugins.level2.table} THEN '2'
                WHEN plugin NOT IN ${plugins.level1.table}
                  AND plugin NOT IN ${plugins.level1-optional.table}
                  AND plugin NOT IN ${plugins.level2.table} THEN '3'
                ELSE '0'
              END
          FROM ${plugins.all.table}
      ),
      current(plugin, server, number, individual, location) AS (
        SELECT plugin, server, number, IIF(individual, 'Instance', 'Server'), 'netprobe'
          FROM ${db.samplers.active}

        UNION ALL

        SELECT plugin, entity, number, 'Server', 'collectionAgent'
          FROM ${db.ca-samplers.active}

        UNION ALL

        SELECT plugin, gateway, number, 'Server', 'gateway'
          FROM ${db.gw-samplers.active}
      ),
      previous(plugin, server, number, individual, location) AS (
        SELECT plugin, server, number, IIF(individual, 'Instance', 'Server'), 'netprobe'
          FROM ${db.samplers.inactive}

        UNION ALL

        SELECT plugin, entity, number, 'Server', 'collectionAgent'
          FROM ${db.ca-samplers.inactive}

        UNION ALL

        SELECT plugin, gateway, number, 'Server', 'gateway'
          FROM ${db.gw-samplers.inactive}
      )

      SELECT
        plugin,
        count(DISTINCT server) servers,
        total(number) instances,
        COALESCE((SELECT COALESCE(sum(total), CASE WHEN lastSeen IS NOT NULL THEN 'Unlimited' ELSE NULL END) FROM ${db.tokens.table} WHERE token = current.plugin), 0) tokensAvailable,
        COALESCE((SELECT total(used) FROM ${db.tokens.table} WHERE token = current.plugin AND total IS NOT NULL), 0) tokensUsed,
        printf('%d %%', COALESCE((SELECT IIF(sum(total) IS NULL, 0, round(total(used) * 100 / total(total))) FROM ${db.tokens.table} WHERE token = current.plugin AND total IS NOT NULL), 0)) tokensUsedPct,
        (SELECT count(*) FROM previous WHERE plugin = current.plugin) previousServers,
        (SELECT total(number) FROM previous WHERE plugin = current.plugin) previousInstances,
        COALESCE(location, ''),
        COALESCE(required, ''),
        COALESCE(level, ''),
        COALESCE(individual, '') as license,
        1
        FROM current
        JOIN levels USING (plugin)
       GROUP BY plugin

      UNION

      SELECT
        plugin,
        0,
        0,
        COALESCE((SELECT COALESCE(sum(total), CASE WHEN lastSeen IS NOT NULL THEN 'Unlimited' ELSE NULL END) FROM ${db.tokens.table} WHERE token = previous.plugin), 0) tokensAvailable,
        0,
        ' 0%',
        count(DISTINCT server),
        total(number),
        COALESCE(location, ''),
        COALESCE(required, ''),
        COALESCE(level, ''),
        COALESCE(individual, '') as license,
        1
        FROM previous
        JOIN levels USING (plugin)
       WHERE plugin NOT IN (SELECT DISTINCT plugin from current)
       GROUP BY plugin

      UNION

      SELECT plugin,
        0,
        0,
        COALESCE((SELECT COALESCE(sum(total), CASE WHEN lastSeen IS NOT NULL THEN 'Unlimited' ELSE NULL END) FROM ${db.tokens.table} WHERE token = a.plugin), 0) tokensAvailable,
        0,
        '0 %',
        0,
        0,
        '',
        COALESCE(required, ''),
        COALESCE(level, ''),
        '',
        1
        FROM ${plugins.all.table} a
        JOIN levels USING (plugin)
       WHERE plugin IN (SELECT DISTINCT plugin from ${db.tokens.table})
         AND plugin NOT IN (SELECT DISTINCT plugin FROM current)
         AND plugin NOT IN (SELECT DISTINCT plugin FROM previous)
       GROUP BY plugin
      ;

  coverage-summary:
    name: Coverage Summary
    dataview:
      group: Monitoring Coverage
    xlsx:
      freeze-to-column: coverageFor
    columns: [ coverageFor, total, complete, "complete %", empty, "empty %", remaining, "remaining %", l1complete, "l1complete %", l1remaining, l2complete, "l2complete %", l2remaining, l3complete, "l3complete %", l3remaining ]
    # The coverage-summary query returns one row per type of summary.
    # This is actively for all Gateways and another for all Probes.
    #
    # Note: The COALESCE() in the percentage lines is necessary in the
    # (rare) case that once all the items are covered we avoid a divide
    # by zero returning NULL.
    query: | #sql
      WITH gw AS (
        SELECT (SELECT count(*) FROM ${db.gateways.active}) total,
               (SELECT count(*) FROM ${db.covered-gateways.table}) covered,
               (SELECT count(*) FROM ${db.empty-gateways.table}) empty,
               (SELECT count(*) FROM ${db.l1covered-gateways.table}) l1covered,
               (SELECT count(*) FROM ${db.l2covered-gateways.table}) l2covered,
               (SELECT count(*) FROM ${db.l3covered-gateways.table}) l3covered
      ), w AS (
        SELECT (SELECT count(*) FROM ${db.probes.active}) total,
               (SELECT count(*) FROM ${db.covered-probes.table}) covered,
               (SELECT count(*) FROM ${db.empty-probes.table}) empty,
               (SELECT count(*) FROM ${db.l1covered-probes.table}) l1covered,
               (SELECT count(*) FROM ${db.l2covered-probes.table}) l2covered,
               (SELECT count(*) FROM ${db.l3covered-probes.table}) l3covered
      ), s AS (
        SELECT (SELECT count(DISTINCT server) FROM ${db.servers.table}) total,
               (SELECT count(DISTINCT server) FROM ${db.covered-servers.table}) covered,
               (SELECT count(DISTINCT server) FROM ${db.empty-servers.table}) empty,
               (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table}) l1covered,
               (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table}) l2covered,
               (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table}) l3covered
      )
      SELECT 'Gateways',
           total,

           covered,
           printf('%d %%', round(covered * 100.0 / total)) coveredPercent,

           empty,
           printf('%d %%', round(empty * 100.0 / total)) emptyPercent,

           total - covered - empty remaining,
           printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,

           l1covered - covered l1covered,
           printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
           total - l1covered - empty l1remaining,

           l2covered - covered l2covered,
           printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
           total - l2covered - empty l2remaining,

           l3covered - covered l3covered,
           printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent,
           total - l3covered - empty l3remaining

        FROM gw

      UNION ALL

      SELECT 'Servers',
           total,
           covered,
           printf('%d %%', round(covered * 100.0 / total)) coveredPercent,
           empty,
           printf('%d %%', round(empty * 100.0 / total)) emptyPercent,
           total - covered - empty remaining,
           printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,
           l1covered - covered l1covered,
           printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
           total - l1covered - empty l1remaining,
           l2covered - covered l2covered,
           printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
           total - l2covered - empty l2remaining,
           l3covered - covered l3covered,
           printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent,
           total - l3covered - empty l3remaining
        FROM s

      UNION ALL

      SELECT 'Probes',
           total,
           covered,
           printf('%d %%', round(covered * 100.0 / total)) coveredPercent,
           empty,
           printf('%d %%', round(empty * 100.0 / total)) emptyPercent,
           total - covered - empty remaining,
           printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,
           l1covered - covered l1covered,
           printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
           total - l1covered - empty l1remaining,
           l2covered - covered l2covered,
           printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
           total - l2covered - empty l2remaining,
           l3covered - covered l3covered,
           printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent,
           total - l3covered - empty l3remaining
        FROM w;

  gateway-coverage:
    name: Gateway Coverage
    dataview:
      group: Monitoring Coverage
    xlsx:
      enable: false
    columns: [ coverage, percent, gateways, remaining, 0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95, 100, description ]
    headlines: > #sql
      SELECT 'totalGateways', (SELECT count(*) FROM ${db.gateways.active})

      UNION

      SELECT 'allGateways', (SELECT count(DISTINCT gateway) FROM ${db.gateways.active})

      UNION

      SELECT 'unusedGateways', (SELECT count(*) FROM ${db.unused-gateways.table})

      ;
    query: | #sql
      WITH gw AS (
        SELECT (SELECT count(*) FROM ${db.gateways.active}) total,
               (SELECT count(*) FROM ${db.covered-gateways.table}) covered,
               (SELECT count(*) FROM ${db.empty-gateways.table}) empty,
               (SELECT count(*) FROM ${db.l1covered-gateways.table}) l1covered,
               (SELECT count(*) FROM ${db.l2covered-gateways.table}) l2covered,
               (SELECT count(*) FROM ${db.l3covered-gateways.table}) l3covered
      ), w AS (
        SELECT total,
               covered,
               empty,
               l1covered,
               l2covered,
               l3covered,
               COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0) l1coveredPercent,
               COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0) l2coveredPercent,
               COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0) l3coveredPercent
          FROM gw LIMIT 1
      )
        SELECT 'Complete Coverage',
             printf('%d %%', round(covered * 100.0 / total)) percent,
             covered,
             '',
             IIF(covered * 100.0 / total > 0, 1, 0),
             IIF(covered * 100.0 / total > 5, 1, 0),
             IIF(covered * 100.0 / total > 10, 1, 0),
             IIF(covered * 100.0 / total > 15, 1, 0),
             IIF(covered * 100.0 / total > 20, 1, 0),
             IIF(covered * 100.0 / total > 25, 1, 0),
             IIF(covered * 100.0 / total > 30, 1, 0),
             IIF(covered * 100.0 / total > 35, 1, 0),
             IIF(covered * 100.0 / total > 40, 1, 0),
             IIF(covered * 100.0 / total > 45, 1, 0),
             IIF(covered * 100.0 / total > 50, 1, 0),
             IIF(covered * 100.0 / total > 55, 1, 0),
             IIF(covered * 100.0 / total > 60, 1, 0),
             IIF(covered * 100.0 / total > 65, 1, 0),
             IIF(covered * 100.0 / total > 70, 1, 0),
             IIF(covered * 100.0 / total > 75, 1, 0),
             IIF(covered * 100.0 / total > 80, 1, 0),
             IIF(covered * 100.0 / total > 85, 1, 0),
             IIF(covered * 100.0 / total > 90, 1, 0),
             IIF(covered * 100.0 / total > 95, 1, 0),
             IIF(covered * 100.0 / total = 100, 1, 0),
             'gateways where all servers have complete coverage'
          FROM w

        UNION ALL

        SELECT 'Incomplete Coverage',
             printf('%d %%', round((total - covered - empty) * 100.0 / total)) percent,
             (total - covered - empty) instances,
             '',
             IIF((total - covered - empty) * 100.0 / total > 0, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 5, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 10, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 15, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 20, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 25, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 30, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 35, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 40, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 45, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 50, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 55, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 60, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 65, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 70, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 75, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 80, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 85, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 90, 1, 0),
             IIF((total - covered - empty) * 100.0 / total > 95, 1, 0),
             IIF((total - covered - empty) * 100.0 / total = 100, 1, 0),
             'gateways where servers do not have all levels of coverage'
          FROM w
        
        UNION ALL

      SELECT 'Incomplete Coverage # Level 1 Covered',
             printf('%d %%', round(l1coveredPercent)) percent,
             l1covered - covered gateways,
             total - l1covered - empty remaining,
             IIF(l1coveredPercent > 0, 1, 0),
             IIF(l1coveredPercent > 5, 1, 0),
             IIF(l1coveredPercent > 10, 1, 0),
             IIF(l1coveredPercent > 15, 1, 0),
             IIF(l1coveredPercent > 20, 1, 0),
             IIF(l1coveredPercent > 25, 1, 0),
             IIF(l1coveredPercent > 30, 1, 0),
             IIF(l1coveredPercent > 35, 1, 0),
             IIF(l1coveredPercent > 40, 1, 0),
             IIF(l1coveredPercent > 45, 1, 0),
             IIF(l1coveredPercent > 50, 1, 0),
             IIF(l1coveredPercent > 55, 1, 0),
             IIF(l1coveredPercent > 60, 1, 0),
             IIF(l1coveredPercent > 65, 1, 0),
             IIF(l1coveredPercent > 70, 1, 0),
             IIF(l1coveredPercent > 75, 1, 0),
             IIF(l1coveredPercent > 80, 1, 0),
             IIF(l1coveredPercent > 85, 1, 0),
             IIF(l1coveredPercent > 90, 1, 0),
             IIF(l1coveredPercent > 95, 1, 0),
             IIF(l1coveredPercent = 100, 1, 0),
             'gateways where servers have level 1 coverage, excluding fully covered'
        FROM w

      UNION ALL

      SELECT 'Incomplete Coverage # Level 2 Covered',
             printf('%d %%', round(l2coveredPercent)) percent,
             l2covered - covered gateways,
             total - l2covered - empty remaining,
             IIF(l2coveredPercent > 0, 1, 0),
             IIF(l2coveredPercent > 5, 1, 0),
             IIF(l2coveredPercent > 10, 1, 0),
             IIF(l2coveredPercent > 15, 1, 0),
             IIF(l2coveredPercent > 20, 1, 0),
             IIF(l2coveredPercent > 25, 1, 0),
             IIF(l2coveredPercent > 30, 1, 0),
             IIF(l2coveredPercent > 35, 1, 0),
             IIF(l2coveredPercent > 40, 1, 0),
             IIF(l2coveredPercent > 45, 1, 0),
             IIF(l2coveredPercent > 50, 1, 0),
             IIF(l2coveredPercent > 55, 1, 0),
             IIF(l2coveredPercent > 60, 1, 0),
             IIF(l2coveredPercent > 65, 1, 0),
             IIF(l2coveredPercent > 70, 1, 0),
             IIF(l2coveredPercent > 75, 1, 0),
             IIF(l2coveredPercent > 80, 1, 0),
             IIF(l2coveredPercent > 85, 1, 0),
             IIF(l2coveredPercent > 90, 1, 0),
             IIF(l2coveredPercent > 95, 1, 0),
             IIF(l2coveredPercent = 100, 1, 0),
             'gateways where servers have level 2 coverage, excluding fully covered'
          FROM w

        UNION ALL

        SELECT 'Incomplete Coverage # Level 3 Covered',
             printf('%d %%', round(l3coveredPercent)) percent,
             l3covered - covered instances,
             total - l3covered - empty remaining,
             IIF(l3coveredPercent > 0, 1, 0),
             IIF(l3coveredPercent > 5, 1, 0),
             IIF(l3coveredPercent > 10, 1, 0),
             IIF(l3coveredPercent > 15, 1, 0),
             IIF(l3coveredPercent > 20, 1, 0),
             IIF(l3coveredPercent > 25, 1, 0),
             IIF(l3coveredPercent > 30, 1, 0),
             IIF(l3coveredPercent > 35, 1, 0),
             IIF(l3coveredPercent > 40, 1, 0),
             IIF(l3coveredPercent > 45, 1, 0),
             IIF(l3coveredPercent > 50, 1, 0),
             IIF(l3coveredPercent > 55, 1, 0),
             IIF(l3coveredPercent > 60, 1, 0),
             IIF(l3coveredPercent > 65, 1, 0),
             IIF(l3coveredPercent > 70, 1, 0),
             IIF(l3coveredPercent > 75, 1, 0),
             IIF(l3coveredPercent > 80, 1, 0),
             IIF(l3coveredPercent > 85, 1, 0),
             IIF(l3coveredPercent > 90, 1, 0),
             IIF(l3coveredPercent > 95, 1, 0),
             IIF(l3coveredPercent = 100, 1, 0),
             'gateways where servers have level 2 coverage, excluding fully covered'
          FROM w

        UNION ALL

        SELECT 'No Coverage',
             printf('%d %%', round(empty * 100.0 / total)) percent,
             empty instances,
             '',
             IIF(empty * 100.0 / total > 0, 1, 0),
             IIF(empty * 100.0 / total > 5, 1, 0),
             IIF(empty * 100.0 / total > 10, 1, 0),
             IIF(empty * 100.0 / total > 15, 1, 0),
             IIF(empty * 100.0 / total > 20, 1, 0),
             IIF(empty * 100.0 / total > 25, 1, 0),
             IIF(empty * 100.0 / total > 30, 1, 0),
             IIF(empty * 100.0 / total > 35, 1, 0),
             IIF(empty * 100.0 / total > 40, 1, 0),
             IIF(empty * 100.0 / total > 45, 1, 0),
             IIF(empty * 100.0 / total > 50, 1, 0),
             IIF(empty * 100.0 / total > 55, 1, 0),
             IIF(empty * 100.0 / total > 60, 1, 0),
             IIF(empty * 100.0 / total > 65, 1, 0),
             IIF(empty * 100.0 / total > 70, 1, 0),
             IIF(empty * 100.0 / total > 75, 1, 0),
             IIF(empty * 100.0 / total > 80, 1, 0),
             IIF(empty * 100.0 / total > 85, 1, 0),
             IIF(empty * 100.0 / total > 90, 1, 0),
             IIF(empty * 100.0 / total > 95, 1, 0),
             IIF(empty * 100.0 / total = 100, 1, 0),
             'gateways where no servers have any level of coverage'
          FROM w
        ;

  server-groups:
    name: Server Groups
    dataview:
      group: Groups
    xlsx:
      freeze-to-column: group
    columns: [ group, servers, complete, "complete %", empty, "empty %", remaining, "remaining %", l1complete, "l1complete %", l1remaining, l2complete, "l2complete %", l2remaining, l3complete, "l3complete %" ]
    query: | #sql
      WITH coverage AS (
        SELECT COALESCE(grouping, 'OTHER') grouping,
               count(DISTINCT a.server) total,
               count(DISTINCT m.server) covered,
               count(DISTINCT e.server) empty,
               count(DISTINCT l1.server) l1covered,
               count(DISTINCT l2.server) l2covered,
               count(DISTINCT l3.server) l3covered
          FROM      ${db.servers.table} a
          LEFT JOIN ${db.covered-servers.table} m USING (server)
          LEFT JOIN ${db.empty-servers.table} e USING (server)
          LEFT JOIN ${db.l1covered-servers.table} l1 USING (server)
          LEFT JOIN ${db.l2covered-servers.table} l2 USING (server)
          LEFT JOIN ${db.l3covered-servers.table} l3 USING (server)
          LEFT JOIN ${db.match-servers.table} grp USING (server)
        GROUP BY grouping
      )
      SELECT DISTINCT
             COALESCE(grouping, 0),
             COALESCE(total, 0),
             COALESCE(covered, 0),
             printf('%d %%', round(covered * 100.0 / total)) coveredPercent,
             COALESCE(empty, 0),
             printf('%d %%', round(empty * 100.0 / total)) emptyPercent,
             COALESCE(total - covered - empty, 0) remaining,
             printf('%d %%', round((total - covered - empty) * 100.0 / total)) remainingPercent,
             COALESCE(l1covered - covered, 0),
             printf('%d %%', round(COALESCE((l1covered - covered) * 100.0 / (total - covered - empty), 0))) l1completePercent,
             COALESCE(total - l1covered - empty, 0) l1remaining,
             COALESCE(l2covered - covered, 0),
             printf('%d %%', round(COALESCE((l2covered - covered) * 100.0 / (total - covered - empty), 0))) l2completePercent,
             COALESCE(total - l2covered - empty, 0) l2remaining,
             COALESCE(l3covered - covered, 0),
             printf('%d %%', round(COALESCE((l3covered - covered) * 100.0 / (total - covered - empty), 0))) l3completePercent
        FROM coverage
       RIGHT JOIN ${db.match-servers.table} USING (grouping)
       ORDER BY CASE grouping WHEN 'OTHER' THEN 'ZZZZZZ' ELSE grouping END COLLATE NOCASE
      ;

  server-coverage:
    name: Server Coverage
    dataview:
      group: Monitoring Coverage
    xlsx:
      enable: false
    columns: [ coverage, percent, servers, remaining, width300, 100, description ]
    headlines: > #sql
      SELECT 'totalServers', (SELECT count(DISTINCT server) FROM ${db.servers.table});
    query: | #sql
      WITH coverage AS (
        SELECT (SELECT count(DISTINCT server) FROM ${db.servers.table}) total,
               (SELECT count(DISTINCT server) FROM ${db.covered-servers.table}) covered,
               (SELECT count(DISTINCT server) FROM ${db.empty-servers.table}) empty,
               (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table}) l1covered,
               (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table}) l2covered,
               (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table}) l3covered
      ), w AS (
        SELECT
               total - covered - empty remaining,
               total - l1covered - empty l1remaining,
               total - l2covered - empty l2remaining,
               total - l3covered - empty l3remaining
          FROM coverage
         LIMIT 1
      )

      SELECT 'Complete Coverage',
             printf('%.0f %%', covered * 100.0 / total) percent,
             covered servers,
             '',
             printf('%d', IIF(covered = 0, 1, covered * 300.0 / total)) width300,
             IIF(covered * 100.0 / total > 99.0, 1, 0),
             'servers with complete coverage of level 1, 2 and 3'
        FROM coverage

      UNION ALL

      SELECT 'Total Level 1 Covered',
             printf('%.0f %%', l1covered * 100.0 / total) percent,
             l1covered servers,
             '',
             printf('%d', IIF(l1covered = 0, 1, l1covered * 300.0 / total)) width300,
             IIF(l1covered * 100.0 / total > 99.0, 1, 0),
             'servers with level 1 coverage'
        FROM coverage, w

      UNION ALL

      SELECT 'Total Level 2 Covered',
             printf('%.0f %%', l2covered * 100.0 / total) percent,
             l2covered servers,
             '',
             printf('%d', IIF(l2covered = 0, 1, l2covered * 300.0 / total)) width300,
             IIF(l2covered * 100.0 / total > 99.0, 1, 0),
             'servers with level 2 coverage'

        FROM coverage, w

      UNION ALL

      SELECT 'Total Level 3 Covered',
             printf('%.0f %%', l3covered * 100.0 / total) percent,
             l3covered servers,
             '',
             printf('%d', IIF(l3covered = 0, 1, l3covered * 300.0 / total)) width300,
             IIF(l3covered * 100.0 / total > 99.0, 1, 0),
             'servers with level 3 coverage'
        FROM coverage, w

      UNION ALL

      SELECT 'Incomplete Coverage',
             printf('%.0f %%', remaining * 100.0 / total) percent,
             remaining servers,
             '',
             printf('%d', IIF(remaining = 0, 1, remaining * 300.0 / total)) width300,
             IIF(remaining * 100.0 / total > 99.0, 1, 0),
             'servers with incomplete coverage'
        FROM coverage, w

      UNION ALL

      SELECT 'Incomplete Coverage # Level 1 Covered',
             printf('%.0f %%', (l1covered - covered) * 100.0 / remaining) percent,
             l1covered - covered servers,
             total - l1covered - empty,
             printf('%d', IIF((l1covered - covered) = 0, 1, (l1covered - covered) * 300.0 / remaining)) width300,
             IIF((l1covered - covered) * 100.0 / total > 99.0, 1, 0),
             'servers with incomplete coverage, but with level 1 covered'
        FROM coverage, w

      UNION ALL

      SELECT 'Incomplete Coverage # Level 2 Covered',
             printf('%.0f %%', (l2covered - covered) * 100.0 / remaining) percent,
             l2covered - covered servers,
             total - l2covered - empty,
             printf('%d', IIF((l2covered - covered) = 0, 1, (l2covered - covered) * 300.0 / remaining)) width300,
             IIF((l2covered - covered) * 100.0 / total > 99.0, 1, 0),
             'servers with incomplete coverage, but with level 2 covered'
        FROM coverage, w

      UNION ALL

      SELECT 'Incomplete Coverage # Level 3 Covered',
             printf('%.0f %%', (l3covered - covered) * 100.0 / remaining) percent,
             l3covered - covered servers,
             total - l3covered - empty,
             printf('%d', IIF((l3covered - covered) = 0, 1, (l3covered - covered) * 300.0 / remaining)) width300,
             IIF((l3covered - covered) * 100.0 / total > 99.0, 1, 0),
             'servers with incomplete coverage, but with level 3 covered'
        FROM coverage, w

      UNION ALL

      SELECT 'No Coverage',
             printf('%.0f %%', empty * 100.0 / total) percent,
             empty servers,
             '',
             printf('%d', IIF(empty = 0, 1, empty * 300.0 / total)) width300,
             IIF(empty * 100.0 / total > 99.0, 1, 0),
             'servers with no coverage'
        FROM coverage;

  missing-coverage:
    name: Missing Coverage
    dataview:
      group: Monitoring Coverage
    xlsx:
      freeze-to-column: serverID
      conditional-format:
        - test:
            columns: [ samplers, dynamicEntities ]
            condition: "="
            type: number
            value: 0
          set:
            - format: warning
        - test:
            columns: samplers
            condition: ">"
            type: number
            value: 0
          set:
            - format: ok
        - test:
            columns: dynamicEntities
            condition: ">"
            type: number
            value: 0
          set:
            - format: ok
        - test:
            columns: l1missing
            condition: "="
            value: ""
          set:
            - format: ok
        - test:
            columns: l1missing
            condition: "<>"
            value: ""
          set:
            - format: warning
        - test:
            columns: l2missing
            condition: "="
            value: ""
          set:
            - format: ok
        - test:
            columns: l2missing
            condition: "<>"
            value: ""
          set:
            - format: warning
        - test:
            columns: l3missing
            condition: "<>"
            value: "missing"
          set:
            - format: ok
        - test:
            columns: l3missing
            condition: "="
            value: "missing"
          set:
            - format: warning
    columns: [ serverID, server, osVersion, probes, samplers, dynamicEntities, l1missing, l2missing, l3missing, gateways, plugins ]
    scramble-columns: [ serverID, server, gateways ]
    headlines: > #sql
      WITH t AS (
        SELECT
          (SELECT count(DISTINCT server) FROM ${db.servers.table}) as total
      )

      SELECT 'servers', total FROM t
      UNION
      SELECT 'serversComplete', (SELECT count(DISTINCT server) FROM ${db.covered-servers.table})
      UNION
      SELECT 'serversIncomplete', (SELECT count(DISTINCT server) FROM ${db.uncovered-servers.table})
      UNION
      SELECT 'serversL1Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table}) FROM t
      UNION
      SELECT 'serversL2Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table}) FROM t
      UNION
      SELECT 'serversL3Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table}) FROM t
      UNION
      SELECT 'serversEmpty', (SELECT count(DISTINCT server) FROM ${db.empty-servers.table})

      ;
    query: | #sql
      SELECT server,
             replace(server, ':'||hostID, ''),
             COALESCE(os, ''),
             (SELECT count(*) FROM ${db.probes.active} WHERE server = u.server) probes,
             (SELECT total(number) FROM ${db.samplers.active} WHERE server = u.server) samplers,
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = u.server) as dynamicEntities,
             COALESCE((SELECT group_concat(CASE missing WHEN '0' THEN NULL WHEN '1' THEN plugin ELSE plugin || '(' || missing || ')' END, ', ')
                         FROM ${db.l1missing-plugins-per-server.table} WHERE server = u.server), '') l1missing,
             COALESCE((SELECT group_concat(CASE missing WHEN '0' THEN NULL WHEN '1' THEN plugin ELSE plugin || '(' || missing || ')' END, ', ')
                         FROM ${db.l2missing-plugins-per-server.table} WHERE server = u.server), '') l2missing,
             (SELECT IIF(server IN (SELECT server FROM ${db.l3covered-servers.table}), '', 'missing')) as l3missing,
             group_concat(gateway, ', '),
             COALESCE((SELECT group_concat(plugins, ', ') FROM (
                          SELECT plugin || IIF(total(number) > 1, printf('(%d)', total(number)), '') plugins
                            FROM ${db.samplers.active}
                           WHERE server = u.server
                           GROUP BY plugin

                          UNION

                          SELECT plugin || IIF(count(plugin) > 1, printf('(%d)', total(number)), '')
                            FROM ${db.ca-samplers.active}
                           WHERE server = u.server
                           GROUP BY plugin

                          ORDER BY 1
                     )), '') plugins
        FROM ${db.uncovered-servers.table} u
       GROUP BY server
       ORDER BY samplers ASC, probes DESC, length(l1missing) DESC, length(l2missing) DESC, l3missing DESC;

  coverage-per-gateway-overview:
    name: ${value} Overview
    dataview:
      group: Gateways
      enable: false
    xlsx:
      enable: false
      freeze-to-column: serverID
      conditional-format:
        - test:
            columns: [ samplers, dynamicEntities ]
            condition: "="
            type: number
            value: 0
          set:
            - format: warning
        - test:
            columns: samplers
            condition: ">"
            type: number
            value: 0
          set:
            - format: ok
        - test:
            columns: dynamicEntities
            condition: ">"
            type: number
            value: 0
          set:
            - format: ok
        - test:
            columns: l1missing
            condition: "="
            value: ""
          set:
            - format: ok
        - test:
            columns: l1missing
            condition: "<>"
            value: ""
          set:
            - format: warning
        - test:
            columns: l2missing
            condition: "="
            value: ""
          set:
            - format: ok
        - test:
            columns: l2missing
            condition: "<>"
            value: ""
          set:
            - format: warning
        - test:
            columns: l3missing
            condition: "<>"
            value: "missing"
          set:
            - format: ok
        - test:
            columns: l3missing
            condition: "="
            value: "missing"
          set:
            - format: warning
    columns: [ serverID, server, osVersion, probes, probeVersion, licenceSources, samplers, dynamicEntities, l1missing, l2missing, l3missing, otherGateways, plugins ]
    scramble-columns: [ serverID, server ]
    type: split
    split-column: gateway
    split-values-query: SELECT ${reports.coverage-per-gateway-overview.split-column} FROM ${db.gateways.active}
    split-values-query-all: SELECT ${reports.coverage-per-gateway-overview.split-column} FROM ${db.gateways.table}
    headlines: > #sql
      WITH t AS (
        SELECT
          (SELECT count(DISTINCT server) FROM ${db.servers.table} WHERE ${split-column} = '${value}') as total
      )

      SELECT 'gatewayName', '${value}'
      UNION
      SELECT 'gatewayHost', (SELECT COALESCE(gatewayHost, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'gatewayPort', (SELECT COALESCE(gatewayPort, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'gatewayVersion', (SELECT COALESCE(version, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'servers', total FROM t
      UNION
      SELECT 'relatedProbes', (SELECT count(*) FROM ${db.probes.active} WHERE server IN (SELECT server FROM ${db.servers.table} WHERE ${split-column} = '${value}')) - total FROM t
      UNION
      SELECT 'serversEmpty', (SELECT count(DISTINCT server) FROM ${db.empty-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversIncomplete', (SELECT count(DISTINCT server) FROM ${db.uncovered-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversComplete', (SELECT count(DISTINCT server) FROM ${db.covered-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversL1Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'serversL2Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'serversL3Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'dynamicEntities', (SELECT total(number) FROM ${db.ca-samplers.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'dynamicEntitiesUnknownServer', (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server IS NULL AND ${split-column} = '${value}')
      UNION
      SELECT 'licenceSource', (SELECT source FROM ${db.gateways.active} WHERE ${split-column} = '${value}')

      ;
    query: | #sql
      SELECT server,
             replace(server, ':'||hostID, ''),
             COALESCE(CASE (SELECT count(DISTINCT os) FROM ${db.probes.active} WHERE server = u.server)
                           WHEN 0 THEN ''
                           WHEN 1 THEN (SELECT os FROM ${db.probes.active} WHERE server = u.server LIMIT 1)
                           ELSE 'multiple'
                           END, '') osVersion,
             (SELECT count(*) FROM ${db.probes.active} WHERE server = u.server) probes,
             COALESCE(CASE (SELECT count(DISTINCT version) FROM ${db.probes.active} WHERE server = u.server)
                           WHEN 0 THEN ''
                           WHEN 1 THEN (SELECT version FROM ${db.probes.active} WHERE server = u.server LIMIT 1)
                           ELSE 'multiple'
                           END, '') probeVersions,
             (SELECT count(DISTINCT source) FROM ${db.servers.table} WHERE server = u.server) licenceSources,
             (SELECT total(number) FROM ${db.samplers.active} WHERE server = u.server) samplers,
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = u.server AND ${split-column} = '${value}') as dynamicEntities,
             COALESCE((SELECT group_concat(CASE missing WHEN '0' THEN NULL WHEN '1' THEN plugin ELSE plugin || '(' || missing || ')' END, ', ')
                         FROM ${db.l1missing-plugins-per-server.table} WHERE server = u.server), '') l1missing,
             COALESCE((SELECT group_concat(CASE missing WHEN '0' THEN NULL WHEN '1' THEN plugin ELSE plugin || '(' || missing || ')' END, ', ')
                         FROM ${db.l2missing-plugins-per-server.table} WHERE server = u.server), '') l2missing,
             (SELECT IIF(server IN (SELECT server FROM ${db.l3covered-servers.table}), '', 'missing')) as l3missing,
             COALESCE((SELECT group_concat(gateway, ', ') FROM ${db.servers.table} WHERE server = u.server AND gateway <> u.gateway), '') otherGateways,
             COALESCE((SELECT group_concat(plugins, ', ') FROM (
                          SELECT plugin || IIF(total(number) > 1, printf('(%d)', total(number)), '') plugins
                            FROM ${db.samplers.active}
                           WHERE server = u.server
                           GROUP BY plugin

                          UNION

                          SELECT plugin || IIF(count(plugin) > 1, printf('(%d)', total(number)), '')
                            FROM ${db.ca-samplers.active}
                           WHERE server = u.server
                           GROUP BY plugin

                          ORDER BY 1
                     )), '') plugins
        FROM ${db.servers.table} u
       WHERE ${split-column} = '${value}'
       GROUP BY server
       
      ORDER BY 1
      ;

  coverage-per-gateway-detail:
    name: ${value} Detail
    dataview:
      group: Gateways
      enable: false
    xlsx:
      enable: false
      freeze-to-column: serverID
      conditional-format:
        - test:
            columns: [ otherGateways, samplers, dynamicEntities ]
            condition: "="
            type: number
            value: 0
          set:
            - columns: [ samplers, dynamicEntities ]
              format: warning
        - test:
            columns: samplers
            condition: ">"
            type: number
            value: 0
          set:
            - format: ok
        - test:
            columns: dynamicEntities
            condition: ">"
            type: number
            value: 0
          set:
            - format: ok
        - test:
            columns: l1missing
            condition: "="
            value: ""
          set:
            - not-rows: "*#*"
              format: ok
        - test:
            columns: l1missing
            condition: "<>"
            value: ""
          set:
            - not-rows: "*#*"
              format: warning
        - test:
            columns: l2missing
            condition: "="
            value: ""
          set:
            - not-rows: "*#*"
              format: ok
        - test:
            columns: l2missing
            condition: "<>"
            value: ""
          set:
            - not-rows: "*#*"
              format: warning
        - test:
            columns: l3missing
            condition: "<>"
            value: "missing"
          set:
            - not-rows: "*#*"
              format: ok
        - test:
            columns: l3missing
            condition: "="
            value: "missing"
          set:
            - not-rows: "*#*"
              format: warning
    columns: [ serverID, server, osVersion, probes, probeName, probePort, probeVersion, licenceSources, otherGateways, samplers, dynamicEntities, l1missing, l2missing, l3missing, plugins ]
    scramble-columns: [ serverID, server, probeName ]
    type: split
    split-column: gateway
    split-values-query: SELECT ${reports.coverage-per-gateway-detail.split-column} FROM ${db.gateways.active}
    split-values-query-all: SELECT ${reports.coverage-per-gateway-detail.split-column} FROM ${db.gateways.table}
    headlines: > #sql
      WITH t AS (
        SELECT
          (SELECT count(DISTINCT server) FROM ${db.servers.table} WHERE ${split-column} = '${value}') as total
      )

      SELECT 'gatewayName', '${value}'
      UNION
      SELECT 'gatewayHost', (SELECT COALESCE(gatewayHost, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'gatewayPort', (SELECT COALESCE(gatewayPort, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'gatewayVersion', (SELECT COALESCE(version, '') FROM ${db.gateways.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'servers', total FROM t
      UNION
      SELECT 'relatedProbes', (SELECT count(*) FROM ${db.probes.active} WHERE server IN (SELECT server FROM ${db.servers.table} WHERE ${split-column} = '${value}')) - total FROM t
      UNION
      SELECT 'serversEmpty', (SELECT count(DISTINCT server) FROM ${db.empty-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversIncomplete', (SELECT count(DISTINCT server) FROM ${db.uncovered-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversComplete', (SELECT count(DISTINCT server) FROM ${db.covered-servers.table} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'serversL1Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'serversL2Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'serversL3Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table} WHERE ${split-column} = '${value}') FROM t
      UNION
      SELECT 'dynamicEntities', (SELECT total(number) FROM ${db.ca-samplers.active} WHERE ${split-column} = '${value}')
      UNION
      SELECT 'dynamicEntitiesUnknownServer', (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server IS NULL AND ${split-column} = '${value}')
      UNION
      SELECT 'licenceSource', (SELECT source FROM ${db.gateways.active} WHERE ${split-column} = '${value}')

      ;
    query: | #sql
      SELECT
            server serverID,
            replace(server, ':'||hostID, '') server,
            COALESCE(CASE (SELECT count(DISTINCT os) FROM ${db.probes.active} WHERE server = u.server)
                           WHEN 0 THEN ''
                           WHEN 1 THEN (SELECT os FROM ${db.probes.active} WHERE server = u.server LIMIT 1)
                           ELSE 'multiple'
                           END, '') osVersion,
             (SELECT count(*) FROM ${db.probes.active} WHERE server = u.server) probes,
             '' probeName,
             '' probePort,
             COALESCE(CASE (SELECT count(DISTINCT version) FROM ${db.probes.active} WHERE server = u.server)
                           WHEN 0 THEN ''
                           WHEN 1 THEN (SELECT version FROM ${db.probes.active} WHERE server = u.server LIMIT 1)
                           ELSE 'multiple'
                           END, '') probeVersions,
             (SELECT count(DISTINCT source) FROM ${db.servers.table} WHERE server = u.server) licenceSources,
             '' otherGateways,
             (SELECT total(number) FROM ${db.samplers.active} WHERE server = u.server) samplers,
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = u.server) as dynamicEntities,
             COALESCE((SELECT group_concat(CASE missing WHEN '0' THEN NULL WHEN '1' THEN plugin ELSE plugin || '(' || missing || ')' END, ', ')
                         FROM ${db.l1missing-plugins-per-server.table} WHERE server = u.server), '') l1missing,
             COALESCE((SELECT group_concat(CASE missing WHEN '0' THEN NULL WHEN '1' THEN plugin ELSE plugin || '(' || missing || ')' END, ', ')
                         FROM ${db.l2missing-plugins-per-server.table} WHERE server = u.server), '') l2missing,
             (SELECT IIF(server IN (SELECT server FROM ${db.l3covered-servers.table} WHERE ${split-column} = '${value}'), '', 'missing')) as l3missing,
             COALESCE((SELECT group_concat(plugins, ', ') FROM (
                          SELECT plugin || IIF(total(number) > 1, printf('(%d)', total(number)), '') plugins
                            FROM ${db.samplers.active}
                           WHERE server = u.server
                           GROUP BY plugin

                          UNION

                          SELECT plugin || IIF(count(plugin) > 1, printf('(%d)', total(number)), '')
                            FROM ${db.ca-samplers.active}
                           WHERE server = u.server
                           GROUP BY plugin

                          ORDER BY 1
                     )), '') plugins
        FROM ${db.servers.table} u
       WHERE ${split-column} = '${value}'
       GROUP BY server
       
      UNION

      SELECT server || ' # ' || probePort serverID,
              '' server,
              COALESCE(os, '') osVersion,
              '' probes,
              probeName,
              probePort,
              COALESCE(version, '') probeVersion,
              '' licenceSources,
              IIF(p.gateway <> '${value}', p.gateway, '') otherGateways,
              (SELECT total(number) FROM ${db.samplers.active} WHERE gateway = p.gateway AND probeName = p.probeName AND probePort = p.probePort) samplers,
              (SELECT total(number) FROM ${db.ca-samplers.active} WHERE gateway = p.gateway AND probeName = p.probeName AND probePort = p.probePort) as dynamicEntities,
              '' l1missing,
              '' l2missing,
              '' l3missing,
              COALESCE((SELECT group_concat(plugins, ', ') FROM (
                          SELECT plugin || IIF(total(number) > 1, printf('(%d)', total(number)), '') plugins
                            FROM ${db.samplers.active}
                           WHERE gateway = p.gateway AND probeName = p.probeName AND probePort = p.probePort
                           GROUP BY plugin

                          UNION

                          SELECT plugin || IIF(count(plugin) > 1, printf('(%d)', total(number)), '')
                            FROM ${db.ca-samplers.active}
                           WHERE gateway = p.gateway AND probeName = p.probeName AND probePort = p.probePort
                           GROUP BY plugin

                          ORDER BY 1
                     )), '') plugins
        FROM ${db.probes.active} p
        WHERE server IN (SELECT server FROM ${db.servers.table} WHERE ${split-column} = '${value}')

      ORDER BY 1
      ;

  plugin-coverage:
    name: Plugin Coverage
    dataview:
      group: Monitoring Coverage
    xlsx:
      enable: false
    columns: [ coverage, percent, servers, width300, 100, remaining, description ]
    headlines: > #sql
      SELECT 'totalServers', (SELECT count(DISTINCT server) FROM ${db.servers.table});
    query: | #sql
      WITH coverage AS (
        SELECT (SELECT count(DISTINCT server) FROM ${db.servers.table}) total,
               (SELECT count(DISTINCT server) FROM ${db.covered-servers.table}) covered,
               (SELECT count(DISTINCT server) FROM ${db.empty-servers.table}) empty,
               (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table}) l1covered,
               COALESCE((SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table}) * 100.0 / (SELECT count(DISTINCT server) FROM ${db.servers.table}), 0) l1coveredPercent,
               (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table}) l2covered,
               COALESCE((SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table}) * 100.0 / (SELECT count(DISTINCT server) FROM ${db.servers.table}), 0) l2coveredPercent,
               (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table}) l3covered,
               COALESCE((SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table}) * 100.0 / (SELECT count(DISTINCT server) FROM ${db.servers.table}), 0) l3coveredPercent
      )
      
      SELECT 'Complete Coverage',
             printf('%d %%', round(covered * 100.0 / total)) percent,
             covered servers,
             printf('%d', IIF(covered = 0, 1, covered * 300.0 / total)) width300,
             IIF(covered * 100.0 / total = 100, 1, 0),
             '',
             'servers with complete coverage'
        FROM coverage

      UNION ALL

      SELECT 'Level 1 Coverage',
             printf('%d %%', round(l1coveredPercent)) percent,
             l1covered servers,
             printf('%d', IIF(l1coveredPercent = 0, 1, 3 * l1coveredPercent)) width300,
             IIF(l1coveredPercent = 100, 1, 0),
             total - l1covered remaining,
             'servers with level 1 coverage'
        FROM coverage

      UNION ALL

      SELECT 'Level 2 Coverage',
             printf('%d %%', round(l2coveredPercent)) percent,
             l2covered servers,
             printf('%d', IIF(l2coveredPercent = 0, 1, 3 * l2coveredPercent)) width300,
             IIF(l2coveredPercent = 100, 1, 0),
             total - l2covered remaining,
             'servers with level 2 coverage'

        FROM coverage

      UNION ALL

      SELECT 'Level 3 Coverage',
             printf('%d %%', round(l3coveredPercent)) percent,
             l3covered servers,
             printf('%d', IIF(l3coveredPercent = 0, 1, 3 * l3coveredPercent)) width300,
             IIF(l3coveredPercent = 100, 1, 0),
             total - l3covered remaining,
             'servers with level 3 coverage'
        FROM coverage

      UNION ALL

      SELECT 'Incomplete Coverage',
             printf('%d %%', round((total - covered - empty) * 100.0 / total)) percent,
             (total - covered - empty) servers,
              printf('%d', iif((total - covered - empty) = 0, 1, (total - covered - empty) * 300.0 / total)) width300,
             IIF((total - covered - empty) * 100.0 / total = 100, 1, 0),
             '',
             'servers with some level 1, 2 or 3 coverage'
        FROM coverage

      UNION ALL

      SELECT 'No Coverage',
             printf('%d %%', round(empty * 100.0 / total)) percent,
             empty servers,
             printf('%d', IIF(empty = 0, 1, empty * 300.0 / total)) width300,
             IIF(empty * 100.0 / total = 100, 1, 0),
             '',
             'servers with no level of coverage'
        FROM coverage;

  licence-sources:
    name: Licence Sources
    dataview:
      group: Licensing
    xlsx:
      freeze-to-column: licenceSource
    columns: [ licenceSource, status, firstSeen, lastSeen, sourceType, path, valid, extendedFormat, gateways, probes, samplers, dynamicEntities, serverTokens, serverTokensUsed, serverTokensFree, licenceName, licenceExpiry, licenceMode, licenceHostname, licenceHostID ]
    headlines: > #sql
      SELECT 'latestUpdate', max(lastSeen)
        FROM ${db.sources.table}

      UNION ALL

      SELECT 'latestLicenceSource', source
        FROM ${db.sources.table}
       WHERE lastSeen = (SELECT max(lastSeen) FROM ${db.sources.table})

      UNION ALL

      SELECT 'totalSources', count(*)
        FROM ${db.sources.table}

      UNION ALL

      SELECT 'erroredSources', count(*)
        FROM ${db.sources.table}
       WHERE status LIKE 'ERROR:%'
       
      UNION ALL

      SELECT 'staleSources', count(*)
        FROM ${db.sources.table}
       WHERE valid = 0
      
      UNION ALL

      SELECT 'totalServerTokens', COALESCE(total(total), 0)
        FROM ${db.tokens.table}
       WHERE token = 'servers'
      ;
    query: | #sql
      WITH os(os, source, lastSeen) AS (SELECT os, source, lastSeen FROM ${db.probes.table})
      SELECT ${db.sources.columns},
             (SELECT IIF((SELECT count(os) FROM os WHERE source = src.source AND lastSeen = src.lastSeen), 1, 0)) as extendedFormat,
             (SELECT count(*) FROM ${db.gateways.table} WHERE source = src.source AND lastSeen = src.lastSeen) AS gateways,
             (SELECT count(*) FROM ${db.probes.table}   WHERE source = src.source AND lastSeen = src.lastSeen) AS probes,
             (SELECT total(number) FROM ${db.samplers.table} WHERE source = src.source AND lastSeen = src.lastSeen) AS samplers,
             (SELECT total(number) FROM ${db.ca-samplers.table} WHERE source = src.source AND lastSeen = src.lastSeen) AS dynamicEntities,
             COALESCE((SELECT COALESCE(total, 'Unlimited') FROM ${db.tokens.table} WHERE token = 'servers' AND source = src.source AND lastSeen = src.lastSeen), 0),
             COALESCE((SELECT COALESCE(used, 0) FROM ${db.tokens.table} WHERE token = 'servers' AND source = src.source AND lastSeen = src.lastSeen), 0),
             COALESCE((SELECT COALESCE(free, 'Unlimited') FROM ${db.tokens.table} WHERE token = 'servers' AND source = src.source AND lastSeen = src.lastSeen), 0),
             COALESCE(licenceName, ''),
             COALESCE(licenceExpiry, ''),
             COALESCE(licenceMode, ''),
             COALESCE(hostname, ''),
             COALESCE(hostID, '')
        FROM ${db.sources.table} src
        LEFT JOIN ${db.sources-licence.table} USING (source)
       WHERE valid = 1

      UNION ALL

      SELECT ${db.sources.columns},
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             0,
             COALESCE(licenceName, ''),
             COALESCE(licenceExpiry, ''),
             COALESCE(licenceMode, ''),
             COALESCE(hostname, ''),
             COALESCE(hostID, '')
        FROM ${db.sources.table}
        LEFT JOIN ${db.sources-licence.table} USING (source)
       WHERE valid = 0

       ORDER BY source;

  unused-gateways:
    name: Unused Gateways
    dataview:
      group: Monitoring Coverage
    xlsx:
      freeze-to-column: gateway
    columns: [ gateway, lastSeen, licenceSources ]
    scramble-columns: [ gateway ]
    query: | #sql
      SELECT gateway, max(lastSeen), group_concat(source, ',')
        FROM ${db.unused-gateways.table}
       GROUP BY gateway

  gateways:
    name: Gateways
    dataview:
      group: Geneos Estate
    xlsx:
      freeze-to-column: gateway
    columns: [ gateway, gatewayHost, gatewayPort, gatewayVersion, servers, probes, samplers, dynamicEntities, dynamicEntitiesUnknownServer, serversComplete, serversIncomplete, serversEmpty, serversl1incomplete, serversl2incomplete, serversl3incomplete, licenseSource ]
    scramble-columns: [ gatewayHost ]
    query: | #sql
      WITH s AS (
        SELECT gateway,
               (SELECT count(DISTINCT server) FROM ${db.servers.table} WHERE gateway = g.gateway) total,
               (SELECT count(DISTINCT server) FROM ${db.covered-servers.table} WHERE gateway = g.gateway) covered,
               (SELECT count(DISTINCT server) FROM ${db.empty-servers.table} WHERE gateway = g.gateway) empty,
               (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table} WHERE gateway = g.gateway) l1covered,
               (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table} WHERE gateway = g.gateway) l2covered,
               (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table} WHERE gateway = g.gateway) l3covered
          FROM ${db.gateways.active} g
         GROUP BY gateway
      )
      SELECT gateway,
             COALESCE(gatewayHost, ''),
             COALESCE(gatewayPort, ''),
             COALESCE(version, ''),
             s.total,
             (SELECT count(*) FROM ${db.probes.active} WHERE gateway = g.gateway),
             (SELECT total(number) FROM ${db.samplers.active} WHERE gateway = g.gateway),
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE gateway = g.gateway),
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server IS NULL AND gateway = g.gateway),
             s.covered,
             s.total - s.covered - s.empty,
             s.empty,
             s.total - s.l1covered - s.empty,
             s.total - s.l2covered - s.empty,
             s.total - s.l3covered - s.empty,
             source
        FROM ${db.gateways.active} g
        LEFT JOIN s USING (gateway)
      ;

  servers:
    name: Servers
    dataview:
      group: Geneos Estate
      enable: false
    xlsx:
      freeze-to-column: serverID
      conditional-format:
        - test:
            columns: [ samplers, dynamicEntities ]
            condition: "="
            type: number
            value: 0
          set:
            - format: warning
        - test:
            columns: samplers
            condition: ">"
            type: number
            value: 0
          set:
            - format: ok
        - test:
            columns: dynamicEntities
            condition: ">"
            type: number
            value: 0
          set:
            - format: ok
        - test:
            columns: l1missing
            condition: "="
            value: ""
          set:
            - format: ok
        - test:
            columns: l1missing
            condition: "<>"
            value: ""
          set:
            - format: warning
        - test:
            columns: l2missing
            condition: "="
            value: ""
          set:
            - format: ok
        - test:
            columns: l2missing
            condition: "<>"
            value: ""
          set:
            - format: warning
        - test:
            columns: l3missing
            condition: "<>"
            value: "missing"
          set:
            - format: ok
        - test:
            columns: l3missing
            condition: "="
            value: "missing"
          set:
            - format: warning
    columns: [ serverID, server, osVersion, probes, samplers, dynamicEntities, l1missing, l2missing, l3missing, licenceSources, gateways, plugins ]
    scramble-columns: [ serverID, server ]
    headlines: > #sql
      WITH t AS (
        SELECT
          (SELECT count(DISTINCT server) FROM ${db.servers.table}) as total
      )

      SELECT 'servers', total FROM t
      UNION
      SELECT 'serversComplete', (SELECT count(DISTINCT server) FROM ${db.covered-servers.table})
      UNION
      SELECT 'serversIncomplete', (SELECT count(DISTINCT server) FROM ${db.uncovered-servers.table})
      UNION
      SELECT 'serversL1Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l1covered-servers.table}) FROM t
      UNION
      SELECT 'serversL2Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l2covered-servers.table}) FROM t
      UNION
      SELECT 'serversL3Incomplete', total - (SELECT count(DISTINCT server) FROM ${db.l3covered-servers.table}) FROM t
      UNION
      SELECT 'serversEmpty', (SELECT count(DISTINCT server) FROM ${db.empty-servers.table})

      ;
    query: | #sql
      SELECT server AS serverID,
             replace(server, ':'||hostID, '') server,
             COALESCE(os, ''),
             (SELECT count(*) FROM ${db.probes.active} WHERE server = s.server),
             (SELECT total(number) FROM ${db.samplers.active} WHERE server = s.server),
             (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = s.server),
             COALESCE((SELECT group_concat(CASE missing WHEN '0' THEN NULL WHEN '1' THEN plugin ELSE plugin || '(' || missing || ')' END, ', ')
                         FROM ${db.l1missing-plugins-per-server.table} WHERE server = s.server), '') l1missing,
             COALESCE((SELECT group_concat(CASE missing WHEN '0' THEN NULL WHEN '1' THEN plugin ELSE plugin || '(' || missing || ')' END, ', ')
                         FROM ${db.l2missing-plugins-per-server.table} WHERE server = s.server), '') l2missing,
             (SELECT IIF(server IN (SELECT server FROM ${db.l3covered-servers.table}), '', 'missing')) as l3missing,
             (SELECT count(DISTINCT source) FROM ${db.servers.table} WHERE server = s.server) licenceSources,
             group_concat(gateway, ','),
             COALESCE((SELECT group_concat(plugins, ', ') FROM (
                          SELECT plugin || IIF(total(number) > 1, printf('(%d)', total(number)), '') plugins
                            FROM ${db.samplers.active}
                           WHERE server = s.server
                           GROUP BY plugin

                          UNION

                          SELECT plugin || IIF(count(plugin) > 1, printf('(%d)', total(number)), '')
                            FROM ${db.ca-samplers.active}
                           WHERE server = s.server
                           GROUP BY plugin

                          ORDER BY 1
                     )), '') plugins
        FROM ${db.servers.table} s
       GROUP BY server
       -- order by the number of sampler plus dynamic entities, so the least monitored appear first
       ORDER BY (SELECT total(number) FROM ${db.samplers.active} WHERE server = s.server) + (SELECT total(number) FROM ${db.ca-samplers.active} WHERE server = s.server)
      ;

  os-versions:
    name: Operating System Versions
    dataview:
      group: Geneos Estate
    columns: [ osVersion, count ]
    query: | #sql
      SELECT os, count(*)
        FROM ${db.servers.table}
       WHERE os IS NOT NULL
       GROUP BY os

      UNION

      SELECT 'Unknown', count(*)
        FROM ${db.servers.table}
       WHERE os IS NULL
      ;

  probe-versions:
    name: Probe Versions
    dataview:
      group: Geneos Estate
    columns: [ probeVersion, count ]
    query: | #sql
      SELECT version, count(*)
        FROM ${db.probes.active}
       WHERE version IS NOT NULL
       GROUP BY version

      UNION

      SELECT 'Unknown', count(*)
        FROM ${db.probes.active}
       WHERE version IS NULL
      ;

  gateway-versions:
    name: Gateway Versions
    dataview:
      group: Geneos Estate
    columns: [ gatewayVersion, count ]
    query: | #sql
      SELECT version, count(*)
        FROM ${db.gateways.active}
       WHERE version IS NOT NULL
       GROUP BY version

      UNION

      SELECT 'Unknown', count(*)
        FROM ${db.gateways.active}
       WHERE version IS NULL
      ;

  licence-allocations:
    name: Licence Allocations
    dataview:
      group: Licensing
    xlsx:
      enable: false
    columns: [ group, category, grouping, token, allocation, user, origin, comment, timestamp ]
    query: | #sql
      SELECT DISTINCT 'group-gateway' 'group', 'gateway' category, '' grouping, '' token, '' allocation, '' user, '' origin, '' comment, '' timestamp
        FROM ${filters.group.gateway.table}

      UNION

      SELECT 'group-gateway # '||grouping,
             'gateway',
             COALESCE(grouping, 'OTHER'),
             COALESCE(token, 'server'),
             COALESCE(allocation, 0),
             COALESCE(a.user, ''),
             COALESCE(a.origin, ''),
             COALESCE(a.comment, ''),
             COALESCE(strftime('%FT%TZ', a.timestamp), '')
        FROM ${filters.group.gateway.table} g
        FULL JOIN ${filters.allocations.gateway.table} a USING (grouping)
      ;

  filters:
    name: Filters
    dataview:
      group: GDNA Information
    xlsx:
      enable: false
    columns: [ filter, type, category, grouping, pattern, user, origin, comment, timestamp ]
    query: | #sql
      SELECT DISTINCT 'exclude-gateway', 'exclude', 'gateway', '', '', '', '', '', ''
        FROM ${filters.exclude.gateway.table}

      UNION

      SELECT 'exclude-gateway # '||gateway filter,
             'exclude' type,
             'gateway' category,
             '' grouping,
             gateway pattern,
             COALESCE(user, "") user,
             COALESCE(origin, "") origin,
             COALESCE(comment, "") comment,
             COALESCE(strftime('%FT%TZ', timestamp), "") timestamp
        FROM ${filters.exclude.gateway.table}

      UNION

      SELECT DISTINCT 'exclude-server', 'exclude', 'server', '', '', '', '', '', ''
        FROM ${filters.exclude.server.table}

      UNION

      SELECT 'exclude-server #'||server,
             'exclude',
             'server',
             '',
             server,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.exclude.server.table}

      UNION

      SELECT DISTINCT 'exclude-source', 'exclude', 'source', '', '', '', '', '', ''
        FROM ${filters.exclude.source.table}

      UNION

      SELECT 'exclude-source # '||source,
             'exclude',
             'source',
             '',
             source,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.exclude.source.table}

      UNION

      SELECT DISTINCT 'exclude-plugin', 'exclude', 'plugin', '', '', '', '', '', ''
        FROM ${filters.exclude.plugin.table}

      UNION

      SELECT 'exclude-plugin # '||plugin,
             'exclude',
             'plugin',
             '',
             plugin,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.exclude.plugin.table}

      UNION

      SELECT DISTINCT 'exclude-hostid', 'exclude', 'hostid', '', '', '', '', '', ''
        FROM ${filters.exclude.hostid.table}

      UNION

      SELECT 'exclude-hostid # '||hostid,
             'exclude',
             'hostid',
             '',
             hostid,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.exclude.hostid.table}

      UNION

      SELECT DISTINCT 'include-gateway', 'include', 'gateway', '', '', '', '', '', ''
        FROM ${filters.include.gateway.table}

      UNION

      SELECT 'include-gateway # '||gateway,
             'include',
             'gateway',
             '',
             gateway,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.include.gateway.table}
      UNION

      SELECT DISTINCT 'include-server', 'include', 'server', '', '', '', '', '', ''
        FROM ${filters.include.server.table}

      UNION

      SELECT 'include-server # '||server,
             'include',
             'server',
             '',
             server,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.include.server.table}

      UNION

      SELECT DISTINCT 'include-source', 'include', 'source', '', '', '', '', '', ''
        FROM ${filters.include.source.table}

      UNION

      SELECT 'include-source # '||source,
             'include',
             'source',
             '',
             source,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.include.source.table}

      UNION

      SELECT DISTINCT 'include-plugin', 'include', 'plugin', '', '', '', '', '', ''
        FROM ${filters.include.plugin.table}

      UNION

      SELECT 'include-plugin # '||plugin,
             'include',
             'plugin',
             '',
             plugin,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.include.plugin.table}

      UNION

      SELECT DISTINCT 'include-hostid', 'include', 'hostid', '', '', '', '', '', ''
        FROM ${filters.include.hostid.table}

      UNION

      SELECT 'include-hostid # '||hostid,
             'include',
             'hostid',
             '',
             hostid,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.include.hostid.table}

      UNION

      SELECT DISTINCT 'group-gateway', 'group', 'gateway', '', '', '', '', '', ''
        FROM ${filters.group.gateway.table}

      UNION

      SELECT 'group-gateway # '||grouping||":"||gateway,
             'group',
             'gateway',
             grouping,
             gateway,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.group.gateway.table}

      UNION

      SELECT DISTINCT 'group-source', 'group', 'source', '', '', '', '', '', ''
        FROM ${filters.group.source.table}

      UNION

      SELECT 'group-source # '||grouping||":"||source,
             'group',
             'source',
             grouping,
             source,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.group.source.table}

      UNION

      SELECT DISTINCT 'group-plugin', 'group', 'plugin', '', '', '', '', '', ''
        FROM ${filters.group.plugin.table}

      UNION

      SELECT 'group-plugin # '||grouping||":"||plugin,
             'group',
             'plugin',
             grouping,
             plugin,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.group.plugin.table}

      UNION

      SELECT DISTINCT 'group-server', 'group', 'server', '', '', '', '', '', ''
        FROM ${filters.group.server.table}

      UNION

      SELECT 'group-server # '||grouping||":"||server,
             'group',
             'server',
             grouping,
             server,
             COALESCE(user, ""),
             COALESCE(origin, ""),
             COALESCE(comment, ""),
             COALESCE(strftime('%FT%TZ', timestamp), "")
        FROM ${filters.group.server.table}
      ;

  servers-with-multiple-licence-sources:
    name: Servers Using Multiple Licenses
    dataview:
      group: Licensing
    xlsx:
      freeze-to-column: serverID
    columns: [ serverID, server, licenceSources, gateways ]
    query: | #sql
      SELECT
             server,
             replace(server, ':'||hostID, '') server,
             count(DISTINCT source),
             group_concat(gateway, ', ')
        FROM ${db.servers.table}
       GROUP BY server
       HAVING count(DISTINCT source) > 1
      ;